// Ionic Starter App
(function() {
    'use strict';

    angular.module('app', [
        'applicat.push.service',
        'ionic',
        'ngCordova',
        'ngResource',
        'ngTemplates',
        'permission',

        "ui.bootstrap.tpls",
        "ui.bootstrap.datepicker"
    ])

    .run([

        '$ionicPlatform', '$rootScope', '$stateParams', '$state', 'AuthService', 'Permission', '$window', 'PushService',

        function($ionicPlatform, $rootScope, $stateParams, $state, AuthService, Permission, $window, PushService) {

            AuthService.init();

            console.log(Permission);
            Permission
                .defineRole('user', function() {
                    var user = AuthService.getUser();
                    console.log(user);
                    if (user) {
                        return true;
                    }
                    return false;
                });




            $ionicPlatform.ready(function() {
                if ($window.cordova && $window.cordova.plugins.Keyboard) {
                    $window.cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);
                    PushService.registerDevice();
                }
                if ($window.StatusBar) {
                    $window.StatusBar.styleDefault();
                }
            });
            AuthService.login('user', 'admin1234')
                .then(function() {
                    $state.go('main.home');
                });

            // $state.go('main.home');
        }
    ])

    .config([

        '$stateProvider', '$httpProvider',

        function($stateProvider, $httpProvider) {

            // Security handler
            $httpProvider.interceptors.push('AuthInterceptor');

            // Allow session
            // $httpProvider.defaults.withCredentials = true;

            $stateProvider

            .state('login', {
                url: '/login',
                templateUrl: 'state/login/login.html',
                controller: 'LoginController as Login'
            })

            .state('main', {
                abstract: true,
                url: '/main',
                templateUrl: 'state/main/main.html',
                controller: 'MainController as Main'
            })

            .state('main.home', {
                url: '/home',
                views: {
                    main: {
                        templateUrl: 'state/mainHome/mainHome.html',
                        controller: 'MainHomeController as Home'
                    }
                },
                data: {
                    permissions: {
                        only: ['user'],
                        redirectTo: {
                            otherwise: {
                                state: 'login'
                            }
                        }
                    }
                }
            })

            // .state('main.list', {
            //     url: '/list',
            //     views: {
            //         main: {
            //             templateUrl: 'state/list/list.html',
            //             controller: 'ListController as List'
            //         }
            //     },
            //     data: {
            //         permissions: {
            //             only: ['user'],
            //             redirectTo: {
            //                 otherwise: {
            //                     state: 'login'
            //                 }
            //             }
            //         }
            //     }
            // })

            .state('main.daumMap', {
                url: '/daumMap/:from',
                views: {
                    main: {
                        templateUrl: 'state/daumMap/daumMap.html',
                        controller: 'DaumMapController as Map'
                    }
                },
                data: {
                    permissions: {
                        only: ['user'],
                        redirectTo: {
                            otherwise: {
                                state: 'login'
                            }
                        }
                    }
                }
            })

            .state('main.detail', {
                url: '/detail/:id',
                views: {
                    main: {
                        templateUrl: 'state/detail/detail.html',
                        controller: 'DetailController as Detail'
                    }
                },
                data: {
                    permissions: {
                        only: ['user'],
                        redirectTo: {
                            otherwise: {
                                state: 'login'
                            }
                        }
                    }
                }
            })

            .state('main.schedule', {
                url: '/schdule/:id/:selectedDate',
                views: {
                    main: {
                        templateUrl: 'state/schedule/schedule.html',
                        controller: 'ScheduleController as Schedule'
                    }
                },
                data: {
                    permissions: {
                        only: ['user'],
                        redirectTo: {
                            otherwise: {
                                state: 'login'
                            }
                        }
                    }
                }
            })

            .state('main.balance', {
                url: '/balance',
                abstract: true,
                views: {
                    main: {
                        templateUrl: 'state/balance/balance.html',
                        controller: 'BalanceController as Balance'
                    }
                }
            })
                .state('main.balance.list', {
                    url: '/list',
                    views: {
                        balance: {
                            templateUrl: 'state/balance/list/balanceList.html',
                            controller: 'BalanceListController as BalanceList'
                        }
                    },
                    data: {
                        permissions: {
                            only: ['user'],
                            redirectTo: {
                                otherwise: {
                                    state: 'login'
                                }
                            }
                        }
                    }

                })
                .state('main.balance.detail', {
                    url: '/detail/:placeName/:points',
                    views: {
                        balance: {
                            templateUrl: 'state/balance/detail/balanceDetail.html',
                            controller: 'BalanceDetailController as BalanceDetail'
                        }
                    },
                    data: {
                        permissions: {
                            only: ['user'],
                            redirectTo: {
                                otherwise: {
                                    state: 'login'
                                }
                            }
                        }
                    }

                })

            .state('main.cancel', {
                url: '/cancel',
                views: {
                    main: {
                        templateUrl: 'state/cancel/cancel.html',
                        controller: 'CancelController as Cancel'
                    }
                },
                data: {
                    permissions: {
                        only: ['user'],
                        redirectTo: {
                            otherwise: {
                                state: 'login'
                            }
                        }
                    }
                }

            })

            .state('main.favorite', {
                url: '/favorite',
                views: {
                    main: {
                        templateUrl: 'state/favorite/favorite.html',
                        controller: 'FavoriteController as Favorite'
                    }
                },
                data: {
                    permissions: {
                        only: ['user'],
                        redirectTo: {
                            otherwise: {
                                state: 'login'
                            }
                        }
                    }
                }

            })

            .state('main.show', {
                url: '/show',
                abstract: true,
                views: {
                    main: {
                        templateUrl: 'state/show/show.html',
                        controller: 'ShowController as Show'
                    }
                }
            })
                .state('main.show.list', {
                    url: '/list',
                    views: {
                        show: {
                            templateUrl: 'state/show/list/showList.html',
                            controller: 'ShowListController as ShowList'
                        }
                    },
                    data: {
                        permissions: {
                            only: ['user'],
                            redirectTo: {
                                otherwise: {
                                    state: 'login'
                                }
                            }
                        }
                    }

                })
                .state('main.show.savedList', {
                    url: '/savedList',
                    views: {
                        show: {
                            templateUrl: 'state/show/savedShow/savedShowList.html',
                            controller: 'SavedShowListController as SavedShowList'
                        }
                    },
                    data: {
                        permissions: {
                            only: ['user'],
                            redirectTo: {
                                otherwise: {
                                    state: 'login'
                                }
                            }
                        }
                    }
                })
                .state('main.show.detail', {
                    url: '/detail/:id',
                    views: {
                        show: {
                            templateUrl: 'state/show/detail/showDetail.html',
                            controller: 'ShowDetailController as ShowDetail'
                        }
                    },
                    data: {
                        permissions: {
                            only: ['user'],
                            redirectTo: {
                                otherwise: {
                                    state: 'login'
                                }
                            }
                        }
                    }
                })

            .state('main.announcements', {
                abstract: true,
                url: '/announcements',
                views: {
                    main: {
                        templateUrl: 'state/announcements/announcements.html',
                        controller: 'AnnouncementsController as Announcements'
                    }
                }
            })
                .state('main.announcements.eventList', {
                    url: '/eventList',
                    views: {
                        announcements: {
                            templateUrl: 'state/announcements/event/eventList.html',
                            controller: 'EventListController as EventList'
                        }
                    },
                    data: {
                        permissions: {
                            only: ['user'],
                            redirectTo: {
                                otherwise: {
                                    state: 'login'
                                }
                            }
                        }
                    }
                })
                .state('main.announcements.eventDetail', {
                    url: '/eventDetail/:id',
                    views: {
                        announcements: {
                            templateUrl: 'state/announcements/event/eventDetail.html',
                            controller: 'EventDetailController as EventDetail'
                        }
                    },
                    data: {
                        permissions: {
                            only: ['user'],
                            redirectTo: {
                                otherwise: {
                                    state: 'login'
                                }
                            }
                        }
                    }
                })
                .state('main.announcements.noticeList', {
                    url: '/noticeList',
                    views: {
                        announcements: {
                            templateUrl: 'state/announcements/notice/noticeList.html',
                            controller: 'NoticeListController as NoticeList'
                        }
                    },
                    data: {
                        permissions: {
                            only: ['user'],
                            redirectTo: {
                                otherwise: {
                                    state: 'login'
                                }
                            }
                        }
                    }
                })
                .state('main.announcements.noticeDetail', {
                    url: '/noticeDetail/:id',
                    views: {
                        announcements: {
                            templateUrl: 'state/announcements/notice/noticeDetail.html',
                            controller: 'NoticeDetailController as NoticeDetail'
                        }
                    },
                    data: {
                        permissions: {
                            only: ['user'],
                            redirectTo: {
                                otherwise: {
                                    state: 'login'
                                }
                            }
                        }
                    }
                });
        } //END
    ]);

})();

/**
 * Created by Andy on 6/6/2015
 * As part of myfitmate
 *
 * Copyright (C) Applicat (www.applicat.co.kr) & Andy Yoon Yong Shin - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * Written by Andy Yoon Yong Shin <andy.shin@applicat.co.kr>, 6/6/2015
 *
 */

/**
 * Created by Andy on 5/26/2015
 * As part of beijingtongclient
 *
 * Copyright (C) Applicat (www.applicat.co.kr) & Andy Yoon Yong Shin - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * Written by Andy Yoon Yong Shin <andy.shin@applicat.co.kr>, 5/26/2015
 *
 */


/*
 *
 * Constant app config
 *
 */


(function() {
    'use strict';

    angular.module('app')
    //.constant("governorUrl", "http://localhost:1337")
    .constant("governorUrl", "http://192.168.0.65:1337")
    // .constant("governorUrl", "http://todaynail.applicat.co.kr")
    .constant("appName", "todayNail")
        .constant("kakaoKey", "42022d8578d6fb558d70ae75766ee900")
        .constant("facebookKey", "983668071678162")
        .constant("googlePushSenderID", "282095615414");
    // .constant("appId", 2)
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Bookings', Bookings);

    Bookings.$inject = ['$resource', 'governorUrl', '$cordovaFileTransfer'];

    function Bookings($resource, governorUrl, $cordovaFileTransfer) {

        var bookingUrl = governorUrl + '/booking' + '/:list' +
            '/:image' + '/:mine' + '/:dateBetween' + '/:request';

        var params = {
            list: '@list',
            image: '@image',
            mine: '@mine',
            dateBetween: '@dateBetween'
        };

        var actions = {
            getBookings: {
                method: 'GET',
                params: {
                    list: 'list'
                }
            },
            getMyBookings: {
                method: 'GET',
                params: {
                    list: 'list',
                    mine: 'mine'
                }
            },
            getBookingsDateBetween: {
                method: 'GET',
                params: {
                    dateBetween: 'dateBetween'
                }
            },

            findById: {
                method: 'GET'
            },

            createBooking: {
                method: 'POST'
            },

            requestBooking: {
                method: 'POST',
                params: {
                    request: 'request'
                }
            },
            updateBooking: {
                method: 'PUT',
                isArray: true,
                headers: {
                    'Content-Type': 'text/plain'
                }
            },
            removeBooking: {
                method: 'DELETE'
            }
        };

        var service = $resource(bookingUrl, params, actions);

        //------------------------
        //  CUSTOM NON-HTTP METHODS
        //------------------------
        service.createBookingWithImage = function(parameters, booking) {
            angular.extend(booking, parameters);
            var filePath = booking.file;
            delete booking.file;
            var options = {
                params: booking,
                chunkedMode: false
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/booking/image', filePath, options)
            };
        };

        service.updateBookingWithImage = function(parameters, booking) {
            angular.extend(booking, parameters);
            var filePath = booking.file;
            delete booking.file;
            var options = {
                params: booking,
                chunkedMode: false,
                httpMethod: 'PUT'
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/booking/image', filePath, options)
            };

        };

        return service;
    }

    // Booking.get({
    //     list: 'list',
    //     category: 'SHOW-POST'
    // }).$promise
    //     .then(function success() {}, function err() {})

    // Bookings.createBookingWithImage({}, bookingWithFile).$promise
    //     .then(function success() {}, function error() {}, function progress(progress) {})

    // require id in bookingWithFile sails' req.param('id') not only look at url params but
    //also looks at the body of req, it is a sails spcific feature.
    // Bookings.createBookingWithImage({}, bookingWithFile).$promise
    //     .then(function success() {}, function error() {}, function progress(progress) {})

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Comments', Comments);

    Comments.$inject = ['$resource', 'governorUrl'];

    function Comments($resource, governorUrl) {

        var commentUrl = governorUrl + '/post/comment';

        var params = {};

        var actions = {
            addCommentToPost: {
                method: 'POST'
            }
        };

        var service = $resource(commentUrl, params, actions);

        return service;
    }

})();

// TODO: remove pushservice and implement own device/push logic
(function() {
    'use strict';

    angular.module('app')
        .factory('Devices', Devices);

    Devices.$inject = ['$resource', 'governorUrl', 'PushService'];

    function Devices($resource, governorUrl, PushService) {

        var deviceUrl = governorUrl + '/device' + '/:sendMessageAll';

        var params = {
            sendMessageAll: '@sendMessageAll'
        };

        var actions = {
            pushAll: {
                method: 'GET',
                params: {
                    sendMessageAll: 'sendMessageAll'
                }
            },

            register: {
                method: 'POST',
            },

            update: {
                method: 'PUT'
            }
        };

        var service = $resource(deviceUrl, params, actions);

        service.getDeviceIdSync = function() {
            var deviceId = PushService.getDeviceId();
            return deviceId;
        };

        return service;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Likes', Likes);

    Likes.$inject = ['$resource', 'governorUrl'];

    function Likes($resource, governorUrl) {

        var likesUrl = governorUrl + '/post' + '/:like' + '/:unlike';

        var params = {
            like: '@like',
            unlike: '@unlike'
        };
        var actions = {
            likePost: {
                method: 'POST'
            },
            unlikePost: {
                method: 'DELETE'
            }
        };

        var service = $resource(likesUrl, params, actions);

        return service;
    }

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Photos', Photos);

    Photos.$inject = ['$resource', 'governorUrl', 'AuthService', '$cordovaFileTransfer'];

    function Photos($resource, governorUrl, AuthService, $cordovaFileTransfer) {

        var photosUrl = governorUrl + '/photo';

        var params = {};

        var actions = {
            removePhoto: {
                method: 'DELETE'
            }
        };

        var service = $resource(photosUrl, params, actions);

        service.uploadPhoto = function(parameters, post) {
            angular.extend(post, parameters);
            var filePath = post.file ? post.file : '[]';
            delete post.file;
            var options = {
                params: post,
                chunkedMode: false,
                headers: {
                    Connection: "close",
                    Authorization: 'Bearer ' + AuthService.getToken()
                }
            };
            console.log(post);
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/photo', filePath, options, true)
            };
        };

        return service;
    }

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Places', Places);

    Places.$inject = ['$resource', 'governorUrl', '$cordovaFileTransfer'];

    function Places($resource, governorUrl, $cordovaFileTransfer) {

        var placeUrl = governorUrl + '/place' + '/:list' + '/:mine' +
            '/:within' + '/:image' + ':photos';

        var params = {
            list: '@list',
            mine: '@mine',
            within: '@within',
            image: '@image',
            photos: '@photos'
        };

        var actions = {
            getPlaces: {
                method: 'GET',
                params: {
                    list: 'list'
                }
            },
            getMyPlaces: {
                method: 'GET',
                params: {
                    list: 'list',
                    mine: 'mine'
                }
            },
            getPlacesWithin: {
                method: 'GET',
                params: {
                    list: 'list',
                    within: 'within'
                }
            },
            getPlacePhotos: {
                method: 'GET',
                params: {
                    photos: 'photos'
                },
                isArray: true
            },
            findById: {
                method: 'GET'
            },
            createPlace: {
                method: 'POST'
            },
            createPlaceWithImage: {
                method: 'POST',
                params: {
                    image: 'image'
                }
            },
            updatePlace: {
                method: 'PUT'
            },
            updatePlaceWithImage: {
                method: 'PUT',
                params: {
                    image: 'image'
                }
            },
            removePlace: {
                method: 'DELETE'
            }
        };

        var service = $resource(placeUrl, params, actions);

        //------------------------
        //  CUSTOM NON-HTTP METHODS
        //------------------------
        service.createPlaceWithImage = function(parameters, place) {
            angular.extend(place, parameters);
            var filePath = place.file;
            delete place.file;
            var options = {
                params: place,
                chunkedMode: false
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/place/image', filePath, options)
            };
        };

        service.updatePlaceWithImage = function(parameters, place) {
            angular.extend(place, parameters);
            var filePath = place.file;
            delete place.file;
            var options = {
                params: place,
                chunkedMode: false,
                httpMethod: 'PUT'
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/place/image', filePath, options)
            };

        };
        return service;
    }

})();

(function() {
    'use strict';
    angular.module('app')
        .factory('Posts', Posts);

    Posts.$inject = ['$resource', 'governorUrl', '$cordovaFileTransfer', 'AuthService'];

    function Posts($resource, governorUrl, $cordovaFileTransfer, AuthService) {

        var postUrl = governorUrl + '/post' + '/:list' +
            '/:image' + '/:mine' + '/:like';

        var params = {
            list: '@list',
            image: '@image',
            mine: '@mine',
            like: '@like'
        };

        var actions = {
            getPosts: {
                method: 'GET',
                params: {
                    list: 'list'
                }
            },
            getMyPosts: {
                method: 'GET',
                params: {
                    list: 'list',
                    mine: 'mine'
                }
            },
            findById: {
                method: 'GET'
            },
            createPost: {
                method: 'POST'
            },
            updatePost: {
                method: 'PUT'
            },
            likePost: {
                method: 'POST',
                params: {
                    like: 'like'
                }
            },
            removePost: {
                method: 'DELETE'
            }
        };

        var service = $resource(postUrl, params, actions);

        //------------------------
        //  CUSTOM NON-HTTP METHODS
        //------------------------
        service.createPostWithImage = function(parameters, post) {
            angular.extend(post, parameters);
            var filePath = post.file ? post.file : '[]';
            delete post.file;
            post.category = "SHOW-POST";
            var options = {
                params: post,
                chunkedMode: false,
                headers: {
                    Connection: "close",
                    Authorization: 'Bearer ' + AuthService.getToken()
                }
            };
            console.log(post);
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/post', filePath, options, true)
            };
        };

        service.updatePostWithImage = function(parameters, post) {
            angular.extend(post, parameters);
            var filePath = post.file;
            delete post.file;
            var options = {
                params: post,
                chunkedMode: false,
                httpMethod: 'PUT',
                headers: {
                    Connection: "close",
                    Authorization: 'Bearer ' + AuthService.getToken()
                }
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/post', filePath, options, true)
            };

        };

        return service;
    }

    // Post.get({
    //     list: 'list',
    //     category: 'SHOW-POST'
    // }).$promise
    //     .then(function success() {}, function err() {})

    // Posts.createPostWithImage({}, postWithFile).$promise
    //     .then(function success() {}, function error() {}, function progress(progress) {})

    // require id in postWithFile sails' req.param('id') not only look at url params but
    //also looks at the body of req, it is a sails spcific feature.
    // Posts.createPostWithImage({}, postWithFile).$promise
    //     .then(function success() {}, function error() {}, function progress(progress) {})


})();

(function() {
    'use strict';
    angular.module('app')
        .factory('Products', Products);

    Products.$inject = ['$resource', 'governorUrl', '$cordovaFileTransfer'];

    function Products($resource, governorUrl, $cordovaFileTransfer) {

        var productUrl = governorUrl + '/product' + '/:list' +
            '/:image' + '/:mine' + '/:checkProductCode';

        var params = {
            list: '@list',
            image: '@image',
            mine: '@mine',
            checkProductCode: '@checkProductCode'
        };

        var actions = {
            getProducts: {
                method: 'GET',
                params: {
                    list: 'list'
                }
            },
            getMyProducts: {
                method: 'GET',
                params: {
                    list: 'list',
                    mine: 'mine'
                }
            },
            checkProductCode: {
                method: 'GET',
                params: {
                    checkProductCode: 'checkProductCode'
                }
            },
            findById: {
                method: 'GET'
            },
            createProduct: {
                method: 'POST'
            },
            updateProduct: {
                method: 'PUT'
            },
            removeProduct: {
                method: 'DELETE'
            }
        };

        var service = $resource(productUrl, params, actions);

        //------------------------
        //  CUSTOM NON-HTTP METHODS
        //------------------------
        service.createProductWithImage = function(parameters, product) {
            angular.extend(product, parameters);
            var filePath = product.file;
            delete product.file;
            var options = {
                params: product,
                chunkedMode: false
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/product/image', filePath, options)
            };
        };

        service.updateProductWithImage = function(parameters, product) {
            angular.extend(product, parameters);
            var filePath = product.file;
            delete product.file;
            var options = {
                params: product,
                chunkedMode: false,
                httpMethod: 'PUT'
            };
            return {
                '$promise': $cordovaFileTransfer.upload(governorUrl + '/product/image', filePath, options)
            };

        };

        return service;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('RoyaltyPoints', RoyaltyPoints);

    RoyaltyPoints.$inject = ['$resource', 'governorUrl'];

    function RoyaltyPoints($resource, governorUrl) {

        var royaltyUrl = governorUrl + '/royaltyPoint' + '/:list' + '/:mine';

        var params = {
            list: '@list',
            mine: '@mine'
        };

        var actions = {
            getRoyaltyPoints: {
                method: 'GET',
                params: {
                    list: 'list'
                }
            },

            getMyRoyaltyPoints: {
                method: 'GET',
                params: {
                    list: 'list',
                    mine: 'mine'
                }
            },

            findById: {
                method: 'GET'
            },

            createRoyaltyPoint: {
                method: 'POST',
            },

            updateRoyaltyPoint: {
                method: 'PUT',
                isArray: true
            },

            removeRoyaltyPoint: {
                method: 'DELETE'
            }
        };

        var service = $resource(royaltyUrl, params, actions);

        return service;
    }

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Users', Users);


    Users.$inject = ['$resource', 'governorUrl'];

    function Users($resource, governorUrl) {

        var userUrl = governorUrl + '/user';

        var params = {};

        var actions = {};

        var service = $resource(userUrl, params, actions);

        return service;
    }

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('daum', daum);

    daum.$inject = ['$window'];

    function daum($window) {

        if ($window.daum) {
            return $window.daum;
        }
        return;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('localStorage', localStorage);

    localStorage.$inject = ['$window'];

    function localStorage($window) {

        if ($window.localStorage) {
            return $window.localStorage;
        }
        return;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('moment', moment);

    moment.$inject = ['$window'];

    function moment($window) {

        if ($window.moment) {
            return $window.moment;
        }
        return;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('_', _);

    _.$inject = ['$window'];

    function _($window) {

        if ($window._) {
            return $window._;
        }
        return;
    }
})();

(function() {
    'use strict';


    angular.module('applicat.push.service', ['ngCordova'])
        .service('PushService', PushService);


    PushService.$inject = ['$http', '$log', '$q', '$cordovaPush', '$cordovaToast', '$cordovaDialogs',
        '$cordovaLocalNotification', '$rootScope', 'googlePushSenderID', 'governorUrl',
        'appName', 'LocalService'
    ];

    function PushService($http, $log, $q, $cordovaPush, $cordovaToast, $cordovaDialogs,
        $cordovaLocalNotification, $rootScope, googlePushSenderID, governorUrl,
        appName, LocalService) {

        var pushservice = this;
        // Type
        var TYPE_ANDROID = 'ANDROID';
        var TYPE_IOS = 'IOS';

        // Trade notification
        var tradeNotification = null;
        var deviceId = null;

        this.getTradeNotification = function() {
            return tradeNotification;
        };

        function setTradeNotification(value) {
            tradeNotification = value;
        }

        this.getDeviceId = function() {
            return deviceId;
        };

        function setDeviceId(value) {
            deviceId = value;
        }

        // Check whether first time
        this.hasTradeNotification = function() {
            return (pushservice.getTradeNotification() != null);
        };

        // Register notification for trade blog
        this.registerTradeNotification = function(optionalType) {

            var deferred = $q.defer();


            $http({
                url: governorUrl + '/push/device',
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                params: {
                    "deviceId": this.getDeviceId(),
                    "optionalType": optionalType
                }
            })
                .success(function(data, status, headers, config) {
                    $log.info("PushService - Success updating device push settings " + JSON.stringify(data));
                    setTradeNotification(data.device.optionalType);
                    deferred.resolve(data);
                })
                .error(function(data, status, headers, config) {
                    deferred.reject(data);
                    $log.info("PushService - Failed updating device push settings");
                });

            return deferred.promise;

        };

        // Register notification for android
        this.registerDevice = function() {

            $log.info("PushService - Register push notification");

            var config = null;

            if (ionic.Platform.isAndroid()) {
                $log.info("PushService - Android push");
                var config = {
                    "senderID": googlePushSenderID
                };
            } else if (ionic.Platform.isIOS()) {
                $log.info("PushService - IOS push");
                var config = {
                    "badge": "true",
                    "sound": "true",
                    "alert": "true"
                };
            }

            if (!config) {
                $log.info("PushService - Not a supported device");


            }

            $cordovaPush.register(config).then(function(result) {
                $log.info("PushService - Register success " + result);

                console.log("PushService - Register success " + result);
                // ** NOTE: Android regid result comes back in the pushNotificationReceived, only iOS returned here
                if (ionic.Platform.isIOS()) {

                    // Needs to change to out server call
                    storeDeviceToken(result, TYPE_IOS);
                }

            }, function(err) {
                $log.info("PushService - Register error " + err)
            });

        }


        // Unregister - Unregister your device token from APNS or GCM not goint to support yet
        ////
        //// ** Instead, just remove the device token from your db and stop sending notifications **
        //this.unregister = function () {
        //    $log.info("PushService - Unregister called");
        //    //removeDeviceToken();
        //}
        //
        //function removeDeviceToken() {
        //    //var tkn = {"token": $scope.regId};
        //    //$http.post('http://192.168.1.16:8000/unsubscribe', JSON.stringify(tkn))
        //    //    .success(function (data, status) {
        //    //        $log.info("Token removed, device is successfully unsubscribed and will not receive push notifications.");
        //    //    })
        //    //    .error(function (data, status) {
        //    //        $log.info("Error removing device token." + data + " " + status)
        //    //    }
        //    //);
        //}

        // Stores the device token app server
        function storeDeviceToken(deviceId, deviceType) {

            var registration = {
                deviceId: deviceId,
                deviceType: deviceType
            }

            $log.info("PushService - register to server: " + JSON.stringify(registration));

            // Get Interest
            var deferred = $q.defer();

            $http({
                url: governorUrl + '/device',
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: registration
            })
                .success(function(data, status, headers, config) {
                    $log.info("PushService - registered to server: " + JSON.stringify(data));

                    // Set devicePushId in PushService
                    setDeviceId(data.device.deviceId);

                    // If push setting exist than set the PushService
                    if (angular.isDefined(data.device.optionalType))
                        setTradeNotification(data.device.optionalType);

                })
                .error(function(data, status, headers, config) {
                    $log.info("PushService - error: " + JSON.stringify(data));
                });

        }

        // Android Notification Received Handler
        function handleAndroid(notification) {
            // ** NOTE: ** You could add code for when app is in foreground or not, or coming from coldstart here too
            //             via the console fields as shown.
            $log.info("In foreground " + JSON.stringify(notification));

            switch (notification.event) {
                case 'registered':

                    if (notification.regid.length > 0) {
                        storeDeviceToken(notification.regid, TYPE_ANDROID);
                    }

                    break;
                case 'message':
                    $log.info(JSON.stringify(notification));

                    if (getPushSetting())
                        window.plugin.notification.local.schedule({
                            title: notification.payload.title,
                            text: notification.payload.message,
                            icon: "res://icon.png",
                            smallIcon: "res://pushicon.png"

                            // parameter documentation:
                            // https://github.com/katzer/cordova-plugin-local-notifications#further-informations-1
                        });

                    break;
                case 'error':
                    $log.info('error');
                    $cordovaDialogs.alert(notification.msg, "Push notification error event");
                    break;
                default:
                    $log.info('default');
                    $cordovaDialogs.alert(notification.event, "Push notification handler - Unprocessed Event");
                    break;
            }
        }

        // IOS Notification Received Handler
        function handleIOS(notification) {
            //// The app was already open but we'll still show the alert and sound the tone received this way. If you didn't check
            //// for foreground here it would make a sound twice, once when received in background and upon opening it from clicking
            //// the notification when this code runs (weird).
            //if (notification.foreground == "1") {
            //    // Play custom audio if a sound specified.
            //    if (notification.sound) {
            //        var mediaSrc = $cordovaMedia.newMedia(notification.sound);
            //        mediaSrc.promise.then($cordovaMedia.play(mediaSrc.media));
            //    }
            //
            //    if (notification.body && notification.messageFrom) {
            //        $cordovaDialogs.alert(notification.body, notification.messageFrom);
            //    }
            //    else $cordovaDialogs.alert(notification.alert, "Push Notification Received");
            //
            //    if (notification.badge) {
            //        $cordovaPush.setBadgeNumber(notification.badge).then(function (result) {
            //            $log.info("Set badge success " + result)
            //        }, function (err) {
            //            $log.info("Set badge error " + err)
            //        });
            //    }
            //}
            //// Otherwise it was received in the background and reopened from the push notification. Badge is automatically cleared
            //// in this case. You probably wouldn't be displaying anything at this point, this is here to show that you can process
            //// the data in this situation.
            //else {
            //    if (notification.body && notification.messageFrom) {
            //        $cordovaDialogs.alert(notification.body, "(RECEIVED WHEN APP IN BACKGROUND) " + notification.messageFrom);
            //    }
            //    else $cordovaDialogs.alert(notification.alert, "(RECEIVED WHEN APP IN BACKGROUND) Push Notification Received");
            //}
        }

        $rootScope.$on('$cordovaPush:notificationReceived', function(event, notification) {
            if (ionic.Platform.isAndroid()) {
                handleAndroid(notification);
            } else if (ionic.Platform.isIOS()) {
                handleIOS(notification);
            }
        });

        function getPushSetting() {
            var setting = JSON.parse(LocalService.get(appName + '_setting'));
            if (setting)
                return setting.push;
            else
                return false;
        }

    };
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('AuthInterceptor', AuthInterceptor);

    AuthInterceptor.$inject = ['$q', '$injector', '$location', 'LocalService', 'appName'];

    function AuthInterceptor($q, $injector, $location, LocalService, appName) {

        return {
            request: function(config) {

                var token = LocalService.get(appName + '_auth_token');

                if (token) {
                    token = angular.fromJson(LocalService.get(appName + '_auth_token')).token;
                }

                if (token) {
                    config.headers['Content-Type'] = 'application/json';
                    config.headers.Authorization = 'Bearer ' + token;
                }
                return config;
            },
            responseError: function(response) {
                if (response.status === 401 || response.status === 403 || response.status === 405 || response.status === 498) {

                    if ($location.path() !== "/login") {

                        LocalService.unset(appName + '_auth_token');
                        $location.path("/login");

                        if (response.data == null || response.data == undefined) {
                            response.data = {
                                message: "권한이 없는 페이지이거나 로그인하지 않았습니다. 로그인해주세요."
                            };
                        }
                    } else {
                        response.data.hideMessage = true;
                    }
                } else if (response.status === 300) {

                    var redirectPath = null;
                    var message = '';
                    switch (response.data.redirectCode) {
                        case 'ACTIVATE':
                            redirectPath = "/resend/false";
                            message: "이메일 인증을 하셔야 서비스 이용이 가능합니다.";
                            break;
                        case 'RESET':
                            redirectPath = "/passReset";
                            message: "비밀번호를 봐꿔주세요.";
                            break;
                    }

                    if ($location.path() !== redirectPath) {

                        $location.path(redirectPath);

                        if (response.data == null || response.data == undefined) {
                            response.data = {
                                message: message
                            };
                        }
                    } else {
                        response.data.hideMessage = true;
                    }
                }
                return $q.reject(response);
            }
        }
    }


    angular.module('app')
        .service("AuthService", AuthService);

    AuthService.$inject = ['$http', '$q', '$location', '$state', 'governorUrl', 'LocalService', 'appName', 'kakaoKey', 'facebookKey', '$cordovaOauth'];

    function AuthService($http, $q, $location, $state, governorUrl, LocalService, appName, kakaoKey, facebookKey, $cordovaOauth) {

        var user = null;
        var selectedApp = {
            name: '어플리켓'
        };

        function setUser(userInfo) {
            user = userInfo;
        }

        this.getUser = function() {
            return user;
        }

        function setApp(app) {
            $rootScope.appName = app.name;
            selectedApp = app;
        }

        this.getApp = function() {
            return selectedApp;
        }

        this.getToken = function() {
            var token = LocalService.get(appName + '_auth_token');

            if (token) {
                token = angular.fromJson(LocalService.get(appName + '_auth_token')).token;
                return token;
            } else {
                $state.go('login');
            }
        }

        this.init = function() {
            var token = JSON.parse(LocalService.get(appName + '_auth_token'));
            if (token != null && token.user != null)
                setUser(token.user);
        }

        this.register = function(user) {

            var deferred = $q.defer();

            $http({
                url: governorUrl + '/user/register',
                method: 'post',
                headers: {
                    'Content-Type': 'application/json'
                },
                params: user
            })
                .success(function(data, status, headers, config) {
                    deferred.resolve(data);
                })
                .error(function(data, status, headers, config) {
                    deferred.reject(data);
                });
            return deferred.promise;
        }

        this.registerWithImage = function(user, file, success, fail) {

            var options = new FileUploadOptions();

            var newUser = angular.copy(user);

            options.params = newUser;
            options.headers = {
                Connection: "close"
            }
            options.chunkedMode = false;

            var ft = new FileTransfer();

            ft.upload(file, encodeURI(governorUrl + '/user/registerWithImage'), success, fail, options, true);
        }

        this.login = function(email, password) {

            var deferred = $q.defer();

            $http({
                url: governorUrl + '/auth/local',
                method: 'post',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: {
                    'identifier': email,
                    'password': password
                }
            })
                .success(function(data, status, headers, config) {

                    console.log(data);
                    LocalService.set(appName + '_auth_token', JSON.stringify(data));
                    setUser(data.user);

                    deferred.resolve(data);
                })
                .error(function(data, status, headers, config) {
                    console.log(data);
                    deferred.reject(data);
                });

            return deferred.promise;

        }

        this.verifyResetCode = function(email, code) {

            var deferred = $q.defer();


            $http({
                url: governorUrl + '/user/passwordresetcomplete',
                method: 'put',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: {
                    'email': email,
                    'code': code
                }
            })
                .success(function(data, status, headers, config) {
                    LocalService.set(appName + '_auth_token', JSON.stringify(data));
                    deferred.resolve(data);
                })
                .error(function(data, status, headers, config) {
                    deferred.reject(data);
                });

            return deferred.promise;

        }

        this.passReset = function(email) {

            var deferred = $q.defer();

            $http({
                url: governorUrl + '/user/resetStart',
                method: 'post',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: {
                    'email': email
                }
            })
                .success(function(data, status, headers, config) {
                    deferred.resolve(data);
                })
                .error(function(data, status, headers, config) {
                    deferred.reject(data);
                });
            return deferred.promise;
        }

        this.logout = function() {
            LocalService.unset(appName + '_auth_token');
            setUser(null);
            $location.path("/login");
        }

        this.changePassword = function(oldPassword, newPassword) {

            var deferred = $q.defer();

            $http({
                url: governorUrl + '/user/changePassword',
                method: 'post',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: {
                    'oldPassword': oldPassword,
                    'newPassword': newPassword
                }
            })
                .success(function(data, status, headers, config) {
                    deferred.resolve(data);
                })
                .error(function(data, status, headers, config) {
                    deferred.reject(data);
                });

            return deferred.promise;
        }

        this.checkNickname = function(nickname) {

            var deferred = $q.defer();

            $http({
                url: governorUrl + '/user/checknickname',
                method: 'get',
                headers: {
                    'Content-Type': 'application/json'
                },
                params: {
                    nickname: nickname
                }
            })
                .success(function(data, status, headers, config) {
                    deferred.resolve(data);
                })
                .error(function(data, status, headers, config) {
                    deferred.reject(data);
                });
            return deferred.promise;
        }

        this.checkEmail = function(email) {

            var deferred = $q.defer();

            $http({
                url: governorUrl + '/user/checkEmail',
                method: 'get',
                headers: {
                    'Content-Type': 'application/json'
                },
                params: {
                    email: email
                }
            })
                .success(function(data, status, headers, config) {
                    deferred.resolve(data);
                })
                .error(function(data, status, headers, config) {
                    deferred.reject(data);
                });
            return deferred.promise;
        }

        this.getMyProfile = function() {
            var deferred = $q.defer();

            $http({
                url: governorUrl + '/user/profile',
                method: 'get',
                headers: {
                    'Content-Type': 'application/json'
                },
            })
                .success(function(data, status, headers, config) {
                    deferred.resolve(data);
                })
                .error(function(data, status, headers, config) {
                    deferred.reject(data);
                });
            return deferred.promise;
        }

        this.updateMyProfile = function(nickname) {
            var deferred = $q.defer();

            $http({
                url: governorUrl + '/user/update',
                method: 'put',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: {
                    nickname: nickname
                }
            })
                .success(function(data, status, headers, config) {
                    deferred.resolve(data);
                })
                .error(function(data, status, headers, config) {
                    deferred.reject(data);
                });
            return deferred.promise;
        }

        this.updateMyProfileWithImage = function(user, file, success, fail) {

            var options = new FileUploadOptions();

            var updateUser = angular.copy(user);

            options.params = updateUser;
            options.httpMethod = 'PUT';
            options.headers = {
                Connection: "close",
                Authorization: 'Bearer ' + this.getToken()
            }
            options.chunkedMode = false;

            var ft = new FileTransfer();

            ft.upload(file, encodeURI(governorUrl + '/user/updateWithImage'), success, fail, options, true);
        }


        this.loginWithKakao = function() {

            var deferred = $q.defer();

            $cordovaOauth.kakao(kakaoKey).then(function(result) {
                result.provider = 'kakao';

                console.log('kakao server result');
                console.log(result);
                $http({
                    url: governorUrl + '/auth/register',
                    method: 'post',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    data: result
                })
                    .success(function(data, status, headers, config) {

                        LocalService.set(appName + '_auth_token', JSON.stringify(data));
                        console.log('kakao response from server');
                        console.log(JSON.stringify(data, null, 2));
                        console.log(JSON.stringify(data.user, null, 2));
                        setUser(data.user);

                        deferred.resolve({
                            message: 'done'
                        });
                    })
                    .error(function(data, status, headers, config) {
                        console.log(data);
                        deferred.reject(data);
                    });


            }, function(error) {
                deferred.reject(error);
            });

            return deferred.promise;
        }

        this.loginWithFacebook = function() {

            var deferred = $q.defer();

            $cordovaOauth.facebook(facebookKey, ["email"]).then(function(result) {
                result.provider = 'facebook';

                console.log('facebook server result');
                console.log(result);
                $http({
                    url: governorUrl + '/auth/register',
                    method: 'post',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    data: result
                })
                    .success(function(data, status, headers, config) {

                        LocalService.set(appName + '_auth_token', JSON.stringify(data));
                        setUser(data.user);
                        console.log('facebook response from our server');
                        console.log(JSON.stringify(data, null, 2));
                        console.log(JSON.stringify(data.user, null, 2));

                        deferred.resolve({
                            message: 'done'
                        });
                    })
                    .error(function(data, status, headers, config) {
                        console.log(data, status, headers, config);
                        deferred.reject(data);
                    });


            }, function(error) {
                deferred.reject(error);
            });

            return deferred.promise;
        }





    }


})();

(function() {
    'use strict';

    angular.module('app')
        .factory('Dom', Dom);

    Dom.$inject = ['$timeout', '$window'];

    function Dom($timeout, $window) {
        var service = {
            focusById: focusById
        };

        return service;

        // USAGE;
        // <input id="daum-map-search-input" type="text">
        // Dom.focusById('daum-map-search-input');
        function focusById(id) {
            $timeout(function() {
                var domElement = $window.document.getElementById(id);
                if (domElement) {
                    domElement.focus();
                }
            });
        }
    }

})();

// Dependencies;
// vm.styleFavorite
// model.current    // eg Detail.currentPost, Detail.currentPlace... rename to current
(function() {
    'use strict';

    angular.module('app')
        .factory('Favorite', Favorite);

    Favorite.$inject = ['$stateParams', 'Message', 'Posts', 'localStorage'];

    function Favorite($stateParams, Message, Posts, localStorage) {

        var service = {
            isFavorite: isFavorite,
            saveToFavorite: saveToFavorite
        };
        return service;

        //------------------------
        //  Implementations
        //------------------------
        function isFavorite(localStorageItem) {
            var favoritesString = localStorage.getItem(localStorageItem);
            var favoritesArray = angular.fromJson(favoritesString);
            if (!Array.isArray(favoritesArray)) {
                favoritesArray = [];
            }
            for (var i = 0; i < favoritesArray.length; i++) {
                var favorite = favoritesArray[i];
                if (favorite.id === $stateParams.id) {
                    return true;
                }
            }
        }

        function saveToFavorite(localStorageItem, vm, model, sendLikeStorageName) {
            var favoritesString = localStorage.getItem(localStorageItem);
            var favoritesArray = angular.fromJson(favoritesString);
            // If no item create empty bucket.
            if (!Array.isArray(favoritesArray)) {
                favoritesArray = [];
            }
            for (var i = 0; i < favoritesArray.length; i++) {
                var favorite = favoritesArray[i];
                // If current favorite exists;
                if (favorite.id === $stateParams.id) {
                    favoritesArray.splice(i, 1);
                    favoritesString = angular.toJson(favoritesArray);
                    localStorage.setItem(localStorageItem, favoritesString);
                    vm.styleFavorite = false;
                    Message.popUp.alert.default('즐겨찾기 알림', '즐겨찾기에서 삭제되었습니다.');
                    return false;
                }
            }
            // If current favorite does not exist then save;
            var favoriteToSave = {
                id: model.current.id,
            };

            addToAttributes(model, favoriteToSave);

            console.log(favoriteToSave);
            favoritesArray.push(favoriteToSave);
            favoritesString = angular.toJson(favoritesArray);
            localStorage.setItem(localStorageItem, favoritesString);
            if (sendLikeStorageName) {
                sendLike(sendLikeStorageName, favoriteToSave.id, model);
            }
            vm.styleFavorite = true;
            Message.popUp.alert.default('즐겨찾기 알림', '즐겨찾기에 추가되었습니다.');
        }

        function addToAttributes(model, favoriteToSave) {
            if (model.current.name) {
                favoriteToSave.name = model.current.name;
            }
            if (model.current.title) {
                favoriteToSave.title = model.current.title;
            }
            if (model.current.photos.length > 0) {
                favoriteToSave.photos = [{
                    url: model.current.photos[0].url
                }];
            }
            if (model.current.location) {
                favoriteToSave.location = {
                    coordinates: model.current.location.coordinates
                };
            }
            if (model.current.address) {
                favoriteToSave.address = model.current.address;
            }
            if (model.current.createdBy) {
                favoriteToSave.createdBy = {};
                favoriteToSave.createdBy.username = model.current.createdBy.username;
            }
            if (model.current.likes) {
                favoriteToSave.likes = model.current.likes;
            }
            if (model.current.comments) {
                favoriteToSave.comments = [];
                for (var i = 0; i < model.current.comments.length; i++) {
                    favoriteToSave.comments.push(1);
                }
            }
        }

        function sendLike(likedOnceStorageItem, id, model) {
            // add to liked once list
            var likedOnceString = localStorage.getItem(likedOnceStorageItem);
            var likedOnceArray = angular.fromJson(likedOnceString);
            if (!Array.isArray(likedOnceArray)) {
                likedOnceArray = [];
            }
            for (var i = 0; i < likedOnceArray.length; i++) {
                var currentId = likedOnceArray[i];
                if (currentId === id) {
                    return false;
                }
            }
            likedOnceArray.push(id);
            likedOnceString = angular.toJson(likedOnceArray);
            localStorage.setItem(likedOnceStorageItem, likedOnceString);
            Posts.likePost({
                post: id
            }).$promise
                .then(function success(postWrapper) {
                    console.log('thisdata');
                    console.log(postWrapper);
                    model.likes = postWrapper.post.likes;
                }, function err(error) {
                    console.log(error);
                });
        }
    } // Service END
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('LocalService', function() {
            return {
                get: function(key) {
                    return localStorage.getItem(key);
                },
                set: function(key, val) {
                    return localStorage.setItem(key, val);
                },
                unset: function(key) {
                    return localStorage.removeItem(key);
                },
                getSession: function(key) {
                    return sessionStorage.getItem(key);
                },
                setSession: function(key, val) {
                    return sessionStorage.setItem(key, val);
                },
                unsetSession: function(key) {
                    return sessionStorage.removeItem(key);
                }
            }
        });


})();

(function() {
    'use strict';
    angular.module('app')
        .factory('Message', Message);

    Message.$inject = ['$ionicLoading', '$ionicPopup'];

    function Message($ionicLoading, $ionicPopup) {
        var service = {

            loading: {
                default: loadingDefault,
                hide: loadingHide
            },
            message: {
                success: messageSuccess,
                error: messageError
            },
            popUp: {
                alert: {
                    default: popUpAlertDefault
                }
            }
        };

        return service;

        function loadingDefault(message) {
            $ionicLoading.show(message);
        }

        function messageSuccess(message) {
            $ionicLoading.show({
                template: '<h4 class="message-success">' + message + '</h4>',
                duration: 2000
            });
        }

        function messageError(message) {
            $ionicLoading.show({
                template: '<h4 class="message-error">' + message + '</h4>',
                duration: 2000
            });
        }

        function loadingHide() {
            $ionicLoading.hide();
        }

        function popUpAlertDefault(title, message) {
            return $ionicPopup.alert({
                title: title || '인터넷이 끊겼습니다.',
                template: message || '인터넷을 켜주세요.'
            });
        }


    }


})();

// Fixes the case where parent veritcal scrolling is disabled on ion-scroll
// element.

// Usage
// ion-scroll[direction="x" scroll-parent]
(function() {
    'use strict';

    angular.module('app')
        .directive('parentScroll', parentScroll);

    parentScroll.$inject = ['$ionicScrollDelegate', '$timeout', '$window'];

    function parentScroll($ionicScrollDelegate, $timeout, $window) {
        return {
            scope: true,
            restrict: 'A',
            compile: compile
        };

        function compile(element, attr) {

            if (!$window.horizontalIonScrollCount) {
                $window.horizontalIonScrollCount = 0;
            }

            $window.horizontalIonScrollCount++
            attr.delegateHandle = "horizontal" + $window.horizontalIonScrollCount;

            return function(scope, element, attr) {
                $timeout(function() {
                    var horizontal = attr.delegateHandle;
                    var sv = $ionicScrollDelegate.$getByHandle(horizontal).getScrollView();

                    var container = sv.__container;

                    var originaltouchStart = sv.touchStart;
                    var originalmouseDown = sv.mouseDown;
                    var originaltouchMove = sv.touchMove;
                    var originalmouseMove = sv.mouseMove;

                    container.removeEventListener('touchstart', sv.touchStart);
                    container.removeEventListener('mousedown', sv.mouseDown);
                    document.removeEventListener('touchmove', sv.touchMove);
                    document.removeEventListener('mousemove', sv.mousemove);


                    sv.touchStart = function(e) {
                        e.preventDefault = function() {}
                        originaltouchStart.apply(sv, [e]);
                    }

                    sv.touchMove = function(e) {
                        e.preventDefault = function() {}
                        originaltouchMove.apply(sv, [e]);
                    }

                    sv.mouseDown = function(e) {
                        e.preventDefault = function() {}

                        if (originalmouseDown) {
                            originalmouseDown.apply(sv, [e]);
                        }

                    }


                    sv.mouseMove = function(e) {
                        e.preventDefault = function() {}

                        if (originalmouseMove) {
                            originalmouseMove.apply(sv, [e]);
                        }

                    }

                    container.addEventListener("touchstart", sv.touchStart, false);
                    container.addEventListener("mousedown", sv.mouseDown, false);
                    document.addEventListener("touchmove", sv.touchMove, false);
                    document.addEventListener("mousemove", sv.mouseMove, false);
                })

            }
        }
    }

})();

//==========================================================================
//              Style for user selection.
//==========================================================================

(function() {
    'use strict';

    angular.module('app')
        .directive('touch', touch);

    touch.$inject = ['$timeout'];

    function touch($timeout) {
        return {
            restrict: 'A',
            link: link
        };

        function link(scope, element, attrs) {
            element.on('click', function(e) {
                element.addClass('touch');
                $timeout(function() {
                    element.removeClass('touch');
                }, 50);

            });
        }
    }

})();

// Makes width of the view available as JS or directive such as collection repeat
// This makes collection repeat to have dynamic width or height which depends on
//the view width or view height;

// usage:
// Required: IndexModel.vw = INT;
// In index.html, body[vw]
// 1) ion-list>ion-item[collection-repeat="item in items" item-height="vw * 0.20"]
// 2) ANY[vw]
// 3) function controller(IndexModel){
//     console.log(IndexModel.vw);
//    }
(function() {
    'use strict';

    angular.module('app')
        .directive('vw', vw);

    vw.$inject = ['$rootScope', '$window'];

    function vw($rootScope, $window) {
        return {
            link: link
        }

        function link(scope, element, attrs) {
            $rootScope.vw = element.prop('offsetWidth');

            $window.addEventListener('resize', function() {
                $rootScope.$apply(function() {
                    $rootScope.vw = element.prop('offsetWidth');
                });
            });
        }
    }


})();

(function() {
    'use strict';
    angular.module('app')
        .filter('filterByTag', filterByTag)

    // filterByTag.$inject = [];
    function filterByTag() {

        return filter;

        function filter(collection, tagName) {
            var resultArray = [];
            if (collection) {

                for (var i = 0; i < collection.length; i++) {
                    var element = collection[i];
                    for (var j = 0; j < element.tags.length; j++) {
                        var tag = element.tags[j];
                        if (tag === tagName) {
                            resultArray.push(element);
                        }
                    }
                }
            }
            return resultArray;
        }
    }


})();

(function() {
    'use strict';

    angular.module('app')
        .controller('EventDetailController', EventDetailController);

    EventDetailController.$inject = ['EventDetailModel', 'Posts', 'Message', '$stateParams', '$scope'];

    function EventDetailController(EventDetailModel, Posts, Message, $stateParams, $scope) {

        var EventDetail = this;
        EventDetail.Model = EventDetailModel;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------

        function doBeforeEnter() {
            getPosts();
        }

        function getPosts() {
            Message.loading.default();
            Posts.get({
                id: $stateParams.id,
                populates: 'photos'
            }).$promise
                .then(function success(postWrapper) {
                    console.log(postWrapper);
                    EventDetailModel.post = postWrapper.post;
                    Message.loading.hide();

                }, function err(error) {
                    console.log(error);
                    Message.popUp.alert.default('이벤트 알림', '종료된 이벤트입니다.');
                });
        }
    } //END
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('EventDetailModel', EventDetailModel);



    function EventDetailModel() {
        var model = {
            post: {
                id: '',
                comments: [],
                photos: [{
                    url: ''
                }],
                content: '',
                title: '',
                category: 'SHOW-POST',
                createdBy: {
                    nickname: ''
                }
            }
        };

        return model;
    }


})();
(function() {
    'use strict';
    angular.module('app')
        .controller('EventListController', EventListController);

    EventListController.$inject = ['EventListModel', 'Posts', '$state', '$scope', 'Message'];

    function EventListController(EventListModel, Posts, $state, $scope, Message) {

        var EventList = this;
        EventList.Model = EventListModel;

        EventList.goToDetailHandler = goToDetailHandler;
        EventList.getNewerPosts = getNewerPosts;
        EventList.getOlderPosts = getOlderPosts;
        EventList.checkForMore = checkForMore;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------

        function goToDetailHandler(post) {
            $state.go('main.announcements.eventDetail', {
                id: post.id
            });
        }

        // Check for newer stuff;
        function getNewerPosts() {
            var currentPosts = EventListModel.postsWrapper.posts;
            Posts.getPosts({
                category: 'EVENT-POST',
                limit: 10,
                newerThan: currentPosts[0].id,
                populates: 'photos'
            }).$promise
                .then(function success(data) {
                    if (!data.posts.length) {
                        Message.popUp.alert.default(
                            '이벤트 알림',
                            '새로운 이벤트가 없습니다.'
                        );
                    }
                    data.posts.forEach(function(post) {
                        currentPosts.unshift(post);
                    });
                    $scope.$broadcast('scroll.refreshComplete');
                }, function err(error) {
                    console.log(error);
                    Message.popUp.alert.default();
                    $scope.$broadcast('scroll.refreshComplete');
                });
        }

        //  Check for older stuff
        function getOlderPosts() {
            var currentPosts = EventListModel.postsWrapper.posts;
            Posts.getPosts({
                category: 'EVENT-POST',
                sort: 'id DESC',
                limit: 10,
                olderThan: currentPosts[currentPosts.length - 1].id,
                popluates: 'photos'
            }).$promise
                .then(function success(data) {
                    data.posts.forEach(function(post) {
                        currentPosts.push(post);
                    });
                    $scope.$broadcast('scroll.infiniteScrollComplete');
                    EventListModel.postsWrapper.more = data.more;
                }, function err(error) {
                    console.log(error);
                    Message.popUp.alert.default();
                    $scope.$broadcast('scroll.infiniteScrollComplete');
                });

        }

        // Check if there is more data if none infinite-scroll is disabled.;
        function checkForMore() {
            return EventListModel.postsWrapper.more;
        }

        function doBeforeEnter() {
            if (EventListModel.postsWrapper.posts.length < 10) {
                Message.loading.default();

                Posts.getPosts({
                    category: 'EVENT-POST',
                    sort: 'id DESC',
                    limit: 10,
                    populates: 'photos'
                }).$promise
                    .then(function success(data) {
                        EventListModel.postsWrapper = data;
                        console.log(data);
                        Message.loading.hide();
                    }, function err(error) {
                        console.log(error);
                        Message.popUp.alert.default();
                    });
            }

        }
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('EventListModel', EventListModel);

    function EventListModel() {
        var model = {
            postsWrapper: {
                posts: [{
                    title: '',
                    content: '',
                    category: '',
                    comments: [],
                    photos: [{
                        url: ''
                    }]
                }],
                more: true
            }
        };

        return model;
    }

})();

(function() {
    'use strict';
    angular.module('app')
        .controller('NoticeDetailController', NoticeDetailController);

    NoticeDetailController.$inject = ['NoticeDetailModel', 'Posts', '$stateParams', '$scope', 'Message'];


    function NoticeDetailController(NoticeDetailModel, Posts, $stateParams, $scope, Message) {

        var NoticeDetail = this;
        NoticeDetail.Model = NoticeDetailModel;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------

        function doBeforeEnter() {
            getPosts();
        }

        function getPosts() {
            Message.loading.default();
            Posts.get({
                id: $stateParams.id,
                populates: 'photos'
            }).$promise
                .then(function success(postWrapper) {
                    console.log(postWrapper);
                    NoticeDetailModel.post = postWrapper.post;
                    Message.loading.hide();

                }, function err(error) {
                    console.log(error);
                    Message.popUp.alert.default('공지사항 알림', '없는 공지사항 입니다');
                });
        }
    }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('NoticeDetailModel', NoticeDetailModel);

    function NoticeDetailModel() {

        var model = {
            post: {
                id: '',
                comments: [],
                photos: [{
                    url: ''
                }],
                content: '',
                title: '',
                category: 'NOTICE-POST',
                createdBy: {
                    nickname: ''
                }
            }
        };

        return model;
    }


})();

(function() {
    'use strict';
    angular.module('app')
        .controller('NoticeListController', NoticeListController);

    NoticeListController.$inject = ['NoticeListModel', 'Posts', '$state', '$scope', 'Message'];

    function NoticeListController(NoticeListModel, Posts, $state, $scope, Message) {

        var NoticeList = this;

        NoticeList.Model = NoticeListModel;
        NoticeList.goToDetailHandler = goToDetailHandler;
        NoticeList.getNewerPosts = getNewerPosts;
        NoticeList.getOlderPosts = getOlderPosts;
        NoticeList.checkForMore = checkForMore;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
        function goToDetailHandler(post) {
            $state.go('main.announcements.noticeDetail', {
                id: post.id
            });
        }

        // Check for newer stuff;
        function getNewerPosts() {
            var currentPosts = NoticeListModel.postsWrapper.posts;
            Posts.getPosts({
                category: 'NOTICE-POST',
                limit: 10,
                newerThan: currentPosts[0].id,
                populates: 'photos'
            }).$promise
                .then(function success(data) {
                    if (!data.posts.length) {
                        Message.popUp.alert.default(
                            '공지사항 알림',
                            '새로운 공지사항이 없습니다.'
                        );
                    }
                    data.posts.forEach(function(post) {
                        currentPosts.unshift(post);
                    });
                    $scope.$broadcast('scroll.refreshComplete');
                }, function err(error) {
                    console.log(error);
                    Message.popUp.alert.default();
                    $scope.$broadcast('scroll.refreshComplete');
                });

        }

        //  Check for older stuff
        function getOlderPosts() {
            var currentPosts = NoticeListModel.postsWrapper.posts;
            Posts.getPosts({
                category: 'NOTICE-POST',
                sort: 'id DESC',
                limit: 10,
                olderThan: currentPosts[currentPosts.length - 1].id,
                populates: 'photos'
            }).$promise
                .then(function success(data) {
                    data.posts.forEach(function(post) {
                        currentPosts.push(post);
                    });
                    $scope.$broadcast('scroll.infiniteScrollComplete');
                    NoticeListModel.postsWrapper.more = data.more;
                }, function err(error) {
                    console.log(error);
                    Message.popUp.alert.default();
                    $scope.$broadcast('scroll.infiniteScrollComplete');
                });

        }

        // Check if there is more data if none infinite-scroll is disabled.;
        function checkForMore() {
            return NoticeListModel.postsWrapper.more;

        }

        function doBeforeEnter() {
            if (NoticeListModel.postsWrapper.posts.length < 10) {
                Message.loading.default();

                Posts.getPosts({
                    category: 'NOTICE-POST',
                    sort: 'id DESC',
                    limit: 10,
                    populates: 'photos'
                }).$promise
                    .then(function success(data) {
                        NoticeListModel.postsWrapper = data;
                        console.log(data);
                        Message.loading.hide();
                    }, function err(error) {
                        console.log(error);
                        Message.popUp.alert.default();
                    });
            }
        }

    }


})();

(function() {
    'use strict';

    angular.module('app')
        .factory('NoticeListModel', NoticeListModel);

    function NoticeListModel() {

        var model = {
            postsWrapper: {
                posts: [{
                    title: '',
                    content: '',
                    category: '',
                    comments: [],
                    photos: [{
                        url: ''
                    }]
                }],
                more: true
            }
        };

        return model;

    }

})();
(function() {
    'use strict';

    angular.module('app')
        .controller('BalanceDetailController', BalanceDetailController);

    BalanceDetailController.$inject = ['BalanceDetailModel', '$stateParams', 'AuthService', '$scope'];

    function BalanceDetailController(BalanceDetailModel, $stateParams, AuthService, $scope) {

        var BalanceDetail = this;
        BalanceDetail.Model = BalanceDetailModel;

        BalanceDetail.placeName = null;
        BalanceDetail.points = null;
        BalanceDetail.username = AuthService.getUser().username;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS;
        //------------------------

        function doBeforeEnter() {
            BalanceDetail.placeName = $stateParams.placeName;
            BalanceDetail.points = $stateParams.points;
            console.log(AuthService.getUser());
        }

    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('BalanceDetailModel', BalanceDetailModel);

    // BalanceDetailModel.$inject = [];

    function BalanceDetailModel() {

        var model = {

        };
        return model;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .controller('BalanceListController', BalanceListController);

    BalanceListController.$inject = ['BalanceListModel', 'RoyaltyPoints', 'Places', '$scope', '$state', '$q', '_'];

    function BalanceListController(BalanceListModel, RoyaltyPoints, Places, $scope, $state, $q, _) {

        var BalanceList = this;
        BalanceList.Model = BalanceListModel;

        BalanceList.goToHandler = goToHandler;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);


        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
        function getMyBalanceList() {
            return RoyaltyPoints.getMyRoyaltyPoints({
                    category: 'NAIL-ROYALTYPOINT'
                }).$promise
                .then(function success(royaltyWrapper) {
                    console.log(royaltyWrapper);
                    var promisesBulk = findByIdsInArray(royaltyWrapper.royaltyPoints);
                    promisesBulk
                        .then(function success(arrayOfPlaces) {
                            console.log(arrayOfPlaces);
                            var royaltyPoints = _.pluck(royaltyWrapper.royaltyPoints, 'points');
                            var names = _.pluck(arrayOfPlaces, 'name');
                            var addresses = _.pluck(arrayOfPlaces, 'address');
                            var photoUrls = _.pluck(_.pluck(_.pluck(arrayOfPlaces, 'photos'), '0'), 'url');
                            var arrayOfResults = [];
                            for (var i = 0; i < royaltyPoints.length; i++) {
                                var result = {};
                                result.name = names[i];
                                result.royaltyPoints = royaltyPoints[i];
                                result.address = addresses[i];
                                result.url = photoUrls[i];
                                arrayOfResults.push(result);
                            }
                            BalanceListModel.current.royaltyPointObjs = arrayOfResults;
                            console.log(arrayOfResults);
                        }, function err(arrayOfErrors) {
                            console.log(arrayOfErrors);
                        });
                }, function err(error) {
                    console.log(error);
                });
        }

        function findByIdsInArray(arrayOfObjects) {
            var arrayOfIds = _.pluck(arrayOfObjects, 'place');
            var arrayOfPromises = _.map(arrayOfIds, function(id) {
                return Places.findById({
                    id: id,
                    populates: 'photos'
                }).$promise;
            });
            var promisesBulkToResolve = $q.all(arrayOfPromises);

            return promisesBulkToResolve;
        }

        function goToHandler(state, params) {
            return $state.go(state, params);
        }

        function doBeforeEnter() {
            getMyBalanceList();
        }

    } //END
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('BalanceListModel', BalanceListModel);

    function BalanceListModel() {

        var model = {
            current: {}
        };
        return model;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .controller('ShowDetailController', ShowDetailController);

    ShowDetailController.$inject = [
        'ShowDetailModel', 'Posts', 'Comments', 'MainModel', '$stateParams', '$scope', 'Message', 'Favorite'
    ];

    function ShowDetailController(ShowDetailModel, Posts, Comments, MainModel, $stateParams, $scope,
        Message, Favorite
    ) {

        var ShowDetail = this;

        ShowDetail.Model = ShowDetailModel;
        ShowDetail.toggleSavePost =
            Favorite.saveToFavorite.bind(null, 'NAIL_SAVED_POSTS', ShowDetail, ShowDetailModel, 'NAIL_LIKED_ONCE');
        ShowDetail.addComment = addComment;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);



        //------------------------
        //  Implementations
        //------------------------
        // TODO: Not working.
        function loadPosts() {
            Message.loading.default();
            return Posts.findById({
                    id: $stateParams.id,
                    populates: 'comments,photos'
                }).$promise
                .then(function success(postWrapper) {
                    console.log(postWrapper.post);
                    ShowDetailModel.current = postWrapper.post;
                    Message.loading.hide();

                }, function err(error) {
                    console.log(error);
                    Message.loading.hide();
                    Message.popUp.alert.default('해당포스트가 없습니다', '지워진 포스트이거나 인터넷이 꺼져있습니다.');
                });
        }


        function addComment(comment) {
            Comments.addCommentToPost({}, {
                content: comment,
                post: $stateParams.id
            }).$promise
                .then(function success(data) {
                    var createdById = data.createdBy;
                    data.createdBy = {};
                    data.createdBy.username = MainModel.user.username;
                    data.createdBy.createdBy = createdById;
                    console.log(data);
                    Message.popUp.alert.default('댓글달기 알림', '댓글을 성공적으로 작성하셨습니다.');
                    ShowDetailModel.current.comments.unshift(data);
                    ShowDetail.comment = null;

                }, function err(error) {
                    console.log(error);
                    Message.popUp.alert.default('댓글달기 알림', '인터넷이 꺼져있습니다.');
                });
            // var commentBody = {
            //     content: comment,
            //     post: $stateParams.id
            // };

            // $http({
            //     url: governorUrl + '/post/comment',
            //     method: 'POST',
            //     headers: {
            //         'Content-Type': 'application/json'
            //     },
            //     data: commentBody
            // })
            //     .success(
            //         function(data) {
            //             var createdById = data.createdBy;
            //             data.createdBy = {};
            //             data.createdBy.username = MainModel.user.username;
            //             data.createdBy.createdBy = createdById;
            //             console.log(data);
            //             Message.popUp.alert.default('댓글달기 알림', '댓글을 성공적으로 작성하셨습니다.');
            //             ShowDetailModel.current.comments.unshift(data);
            //             ShowDetail.comment = null;

            //         })
            //     .error(function(error) {

            //         console.log(error);
            //         Message.popUp.alert.default('댓글달기 알림', '인터넷이 꺼져있습니다.');
            //     });

        }

        function doBeforeEnter() {
            loadPosts();
            ShowDetail.styleFavorite = Favorite.isFavorite('NAIL_SAVED_POSTS');
        }





    } //END
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('ShowDetailModel', ShowDetailModel);

    function ShowDetailModel() {

        var model = {
            current: {
                id: '',
                comments: [],
                photos: [{
                    url: ''
                }],
                content: '',
                title: '',
                category: 'SHOW-POST',
                createdBy: {
                    nickname: ''
                },
                likes: ''
            }
        };

        return model;

    }


})();

(function() {
    'use strict';
    angular.module('app')
        .controller('ShowListController', ShowListController);

    ShowListController.$inject = ['ShowListModel', 'Posts', '$state', '$scope',
        'Message'
    ];

    function ShowListController(ShowListModel, Posts, $state, $scope,
        Message
    ) {

        var ShowList = this;
        ShowList.Model = ShowListModel;

        ShowList.goToDetailHandler = goToDetailHandler;
        ShowList.getNewerPosts = getNewerPosts;
        ShowList.getOlderPosts = getOlderPosts;
        ShowList.checkForMore = checkForMore;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
        function goToDetailHandler(post) {
            $state.go('main.show.detail', {
                id: post.id
            });
        }

        // Check for newer stuff;
        function getNewerPosts() {
            var currentPosts = ShowListModel.postsWrapper.posts;
            Posts.getPosts({
                category: 'SHOW-POST',
                limit: 10,
                newerThan: currentPosts[0] && currentPosts[0].id,
                populates: 'photos'
            }).$promise
                .then(function success(data) {
                    if (!data.posts.length) {
                        Message.popUp.alert.default(
                            '새로운포스트가 없습니다',
                            '나중에 다시 확인해주세요'
                        );
                    }
                    data.posts.forEach(function(post) {
                        currentPosts.unshift(post);
                    });
                    $scope.$broadcast('scroll.refreshComplete');
                }, function err(error) {
                    console.log(error);
                    Message.popUp.alert.default();
                    $scope.$broadcast('scroll.refreshComplete');
                });
        }

        //  Check for older stuff
        function getOlderPosts() {
            var currentPosts = ShowListModel.postsWrapper.posts;
            Posts.getPosts({
                category: 'SHOW-POST',
                sort: 'id DESC',
                limit: 10,
                olderThan: currentPosts[currentPosts.length - 1] && currentPosts[currentPosts.length - 1].id,
                populates: 'photos'
            }).$promise
                .then(function success(data) {
                    data.posts.forEach(function(post) {
                        currentPosts.push(post);
                    });
                    $scope.$broadcast('scroll.infiniteScrollComplete');
                    ShowListModel.postsWrapper.more = data.more;
                }, function err(error) {
                    console.log(error);
                    Message.popUp.alert.default();
                    $scope.$broadcast('scroll.infiniteScrollComplete');
                });

        }

        // Check if there is more data if none infinite-scroll is disabled.;
        function checkForMore() {
            return ShowListModel.postsWrapper.more;
        }

        function doBeforeEnter() {
            if (ShowListModel.postsWrapper.posts.length < 10) {
                Message.loading.default();

                Posts.getPosts({
                    category: 'SHOW-POST',
                    sort: 'id DESC',
                    limit: 10,
                    populates: 'photos'
                }).$promise
                    .then(function success(data) {
                        console.log('this');
                        console.log(data);
                        ShowListModel.postsWrapper = data;
                        Message.loading.hide();
                    }, function err(error) {
                        console.log(error);
                        Message.popUp.alert.default();
                    });
            }
        }

    }


})();

(function() {
    'use strict';

    angular.module('app')
        .factory('ShowListModel', ShowListModel);

    function ShowListModel() {

        var model = {
            postsWrapper: {
                posts: [{
                    title: '',
                    content: '',
                    category: '',
                    comments: [],
                    photos: [{
                        url: ''
                    }]
                }],
                more: true
            },


        };

        return model;

    }

})();

(function() {
    'use strict';

    angular.module('app')
        .controller('SavedShowListController', SavedShowListController);

    SavedShowListController.$inject = ['SavedShowListModel', '$state', '$scope', 'localStorage'];

    function SavedShowListController(SavedShowListModel, $state, $scope, localStorage) {

        var SavedShowList = this;
        SavedShowList.Model = SavedShowListModel;

        SavedShowList.goToDetailHandler = goToDetailHandler;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
        function doBeforeEnter() {
            SavedShowListModel.posts = angular.fromJson(localStorage.getItem('NAIL_SAVED_POSTS'));
            console.log('this');
            console.log(SavedShowListModel.posts);
        }


        function goToDetailHandler(post) {
            $state.go('main.show.detail', {
                id: post.id
            });
            //MVP2: resave. likeCounts, and commentCounts.
        }

    }

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('SavedShowListModel', SavedShowListModel);

    SavedShowListModel.$inject = [];

    function SavedShowListModel() {

        var model = {

        };
        return model;
    }
})();

(function() {
    'use strict';
    angular.module('app')
        .controller('AnnouncementsController', AnnouncementsController);

    AnnouncementsController.$inject = ['$state', 'AnnouncementsModel'];

    function AnnouncementsController($state, AnnouncementsModel) {

        var Announcements = this;
        Announcements.Model = AnnouncementsModel;

        Announcements.goToHandler = goToHandler;

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------

        function goToHandler(state, params) {
            return $state.go(state, params);
        }

    }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('AnnouncementsModel', AnnouncementsModel);



    function AnnouncementsModel() {
        var model = {

        };

        return model;

    }


})();
(function() {
    'use strict';
    angular.module('app')
        .controller('BalanceController', BalanceController);

    BalanceController.$inject = ['BalanceModel'];

    function BalanceController(BalanceModel) {

        var Balance = this;
        Balance.Model = BalanceModel;

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('BalanceModel', BalanceModel);

    // BalanceModel.$inject = [];

    function BalanceModel() {

        var model = {

        };
        return model;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .controller('CancelController', CancelController);

    CancelController.$inject = ['CancelModel', 'Bookings', 'Message', '$scope', 'moment', '$http', 'governorUrl'];

    function CancelController(CancelModel, Bookings, Message, $scope, moment, $http, governorUrl) {

        var Cancel = this;
        Cancel.Model = CancelModel;

        Cancel.cancelHandler = updateStatus.bind(null, 'CANCELED');
        Cancel.isCanceledOrDone = isCanceledOrDone;
        Cancel.isDone = isDone;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
        function getMyBookings() {

            // return Bookings.getBookings({
            return Bookings.getMyBookings({
                    // placeId: "55caf72b3bd8fa7854f8e112",
                    from: moment().clone().subtract(1, 'years').toDate().getTime(),
                    to: moment().clone().add(1, 'years').toDate().getTime(),
                }).$promise
                .then(function success(bookingsWrapper) {
                    console.log(bookingsWrapper);
                    CancelModel.current.bookings = bookingsWrapper.bookings;
                }, function err(error) {
                    Message.popUp.alert.default('인터넷이 꺼져있습니다', '인터넷을 연결해주세요.');
                    console.log(error);
                });
        }

        function updateStatus(statusString, booking) {
            booking.status = statusString;
            console.log(booking);

            $http({
                url: governorUrl + '/booking',
                method: 'PUT',
                data: booking
            })
                .success(function(data) {
                    console.log(data);
                    Message.loading.hide();
                    Message.popUp.alert.default('예약취소 알림', '예약이 취소 되었습니다.');

                })
                .error(function(error) {
                    console.log(error);

                    Message.loading.hide();
                });

            // return Bookings.updateBooking({}, booking).$promise
            //     .then(function success(data) {
            //         console.log(data);
            //         Message.popUp.alert.default('예약취소 알림', '예약이 취소 되었습니다.');
            //         // Array.prototype.splice.call(CancelModel.current.bookings, index, 1);

            //     }, function err(error) {
            //         console.log(error);

            //     });
        }


        function isCanceledOrDone(booking) {
            if (booking.status === 'CANCELED' || booking.status === 'DONE') {
                return true;
            } else {
                return false;
            }
        }

        function isDone(booking) {
            return booking.status === 'DONE' ? 'done' : 'not-done';
        }

        function doBeforeEnter() {
            getMyBookings();
        }
    } // Factory END

})();

(function() {
    'use strict';
    angular.module('app')
        .factory('CancelModel', CancelModel);

    // CancelModel.$inject = [];

    function CancelModel() {
        var data = {
            current: {
                bookings: [{
                    datetime: new Date(),
                    products: [{
                        product: {
                            name: '우늘 네일'
                        },
                        amount: 1
                    }],
                    place: {
                        name: 'place1'
                    },
                    status: 'CANCELLED'
                }, {
                    datetime: new Date(),
                    products: [{
                        product: {
                            name: '오늘 네일 2'
                        },
                        amount: 1
                    }],
                    place: {
                        name: 'place2'
                    },
                    status: 'PROCESSING'
                }]
            }
        };

        return data;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .controller('DaumMapController', DaumMapController);

    DaumMapController.$inject = ['DaumMapModel', '$ionicModal', '$scope', '$state',
        '$stateParams', 'Dom'
    ];

    function DaumMapController(DaumMapModel, $ionicModal, $scope, $state,
        $stateParams, Dom) {

        var Map = this;
        Map.Model = DaumMapModel;

        Map.searchType = "address";



        Map.findMeThenSearchNearBy = DaumMapModel.findMeThenSearchNearBy;

        Map.searchLocationNearBy = function(value) {

            if (Map.searchType === "address")
                return DaumMapModel.searchLocationNearBy(value);
            else
                return DaumMapModel.searchPlaceByName(value);
        };


        Map.goToDetailHandler = function() {
            DaumMapModel.modal.hide();
            $state.go('main.detail', {
                id: DaumMapModel.selectedPlace.id
            });
        };
        Map.goToHandler = function(state, params) {
            $state.go(state, params);
        };


        // Make currently selected place from DaumMapDirective available at ModalView
        Map.selectedPlace = DaumMapModel.selectedPlace;

        $scope.$on('$ionicView.enter', function() {
            // Set Modal
            $ionicModal.fromTemplateUrl('state/daumMap/placeModal.html', {
                scope: $scope,
                animation: 'slide-in-up'
            })
                .then(function(modal) {
                    DaumMapModel.modal = modal;
                });
            DaumMapModel.domMap.relayout();
        });

        //------------------------
        //  APP SPECIFIC FUNCTION
        //------------------------
        $scope.$on('$ionicView.enter', function() {
            if ($stateParams.from === 'quick') {
                Map.title = '바로서비스';
            } else {
                Map.title = '전체보기';
            }
            focusInput($stateParams, Dom);
        });

        function focusInput($stateParams, Dom) {
            if ($stateParams.from === 'homeInput') {
                Dom.focusById('daum-map-search-input');
            }
        }
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .directive('daumMap', daumMap);

    daumMap.$inject = ['DaumMapModel', 'Places', 'Bookings', '$state', '$cordovaGeolocation', 'Message', '$q',
        '$stateParams', 'daum', '_', 'moment'
    ];

    function daumMap(DaumMapModel, Places, Bookings, $state, $cordovaGeolocation, Message, $q, $stateParams, daum, _, moment) {
        return {
            scope: {
                markerSrc: '@',
                markerClickedSrc: '@',
                markerWidth: '@',
                markerHeight: '@',
            },
            compile: function(element) {
                //==========================================================================
                //              Global Map Property
                //==========================================================================
                // Initiate map
                var interval = 30;
                var DOM = element[0];
                var mapOptions = {
                    center: new daum.maps.LatLng(37.5, 127),
                    level: 4,
                    draggable: true
                };
                daum.maps.disableHD();
                var map = new daum.maps.Map(DOM, mapOptions);
                // place service
                var ps = new daum.maps.services.Places();

                var filterValue = null;
                // ==========================================================================
                //              HELPER FUNCTIONS
                // ==========================================================================
                // filter query
                function filterPlaces(places, rangeMinutes) {

                    var currentMoment = setCurrentMoment();

                    var arrayOfIds = _.pluck(places, 'id');

                    var arrayOfPromises = _.map(arrayOfIds, function(id) {
                        return Bookings.getBookingsDateBetween({
                            placeId: id,
                            from: currentMoment.clone().set({
                                hour: 0,
                                minute: 0,
                                second: 0
                            }).toDate().getTime(),
                            to: currentMoment.clone().set({
                                hour: 23,
                                minute: 59,
                                second: 59
                            }).toDate().getTime()
                        }).$promise;
                    });

                    return $q.all(arrayOfPromises)
                        .then(function success(arrayOfBookingsWrapper) {

                            var availabilities = checkAvailableSlots(places, arrayOfBookingsWrapper, interval, currentMoment, rangeMinutes);

                            if (availabilities.length === 0) {
                                return [];
                            }
                            for (var i = places.length - 1; i >= 0; i--) {
                                if (availabilities[i] === 'unavailable') {
                                    places.splice(i, 1);
                                }
                            }

                            return places;

                        }, function err(arrayOfErrors) {
                            console.log(arrayOfErrors);
                        });
                }

                function setCurrentMoment() {
                    var currentMinute = moment().get('minute');
                    var currentMoment = null;
                    if (currentMinute <= 30) {
                        currentMoment = moment().set({
                            minutes: 29
                        });
                    } else {
                        currentMoment = moment().set({
                            minutes: 59
                        });
                    }
                    return currentMoment;
                }

                function checkAvailableSlots(places, arrayOfBookingsWrapper, interval, currentMoment, rangeMinutes) {
                    var todayInt = currentMoment.clone().get('day');

                    var closingMomentsForToday = [];
                    angular.forEach(places, function(place, i) {
                        console.log(place);
                        var endHourArray = place.openingHours[todayInt].end.split(':');
                        var hours = endHourArray[0];
                        var minutes = endHourArray[1];
                        var closingMoment = moment().set({
                            hour: hours,
                            minutes: minutes
                        });
                        if (place.openingHours[todayInt].start === place.openingHours[todayInt].end) {
                            places.splice(i, 1, null);
                            arrayOfBookingsWrapper.splice(i, 1, null);
                        } else if (currentMoment.isAfter(closingMoment)) {
                            places.splice(i, 1, null);
                            arrayOfBookingsWrapper.splice(i, 1, null);
                        } else {
                            closingMomentsForToday.push(closingMoment);
                        }
                    });
                    var i = 0;
                    for (i = places.length - 1; i >= 0; i--) {
                        if (places[i] === null) {
                            places.splice(i, 1);
                            arrayOfBookingsWrapper.splice(i, 1);
                        }
                    }
                    if (places.length === 0) {
                        Message.popUp.alert.default('바로검색 알림', '지금은 검색주위의 샵들이 모두 닫았습니다, 내일 이용해주시거나, 다른지역을 검색해주세요');
                        return [];
                    }


                    var arrayOfBookings = _.map(arrayOfBookingsWrapper, function(bookingsWrapper) {
                        return bookingsWrapper.bookings;
                    });
                    console.log('arrayOfBookings');
                    console.log(arrayOfBookings);
                    var arrayOfDurations = _.map(arrayOfBookings, function(bookings) {
                        return _.map(bookings, function(booking) {
                            return booking.products[0].product.duration;
                        });
                    });
                    var arrayOfBookingsMoment = []; // [ [newbooking, newbooking,... ], []]
                    for (i = 0; i < arrayOfDurations.length; i++) {
                        var resultArray_i = []; // inner [] of resultArray = [ [], [], ... ]
                        var bookings = arrayOfBookings[i];
                        var durations = arrayOfDurations[i];
                        var place = places[i];
                        console.log('place');
                        console.log(place);
                        for (var j = 0; j < durations.length; j++) {
                            var booking = bookings[i];
                            var datetime = booking.datetime;
                            var bookingMoment = moment(datetime);
                            var duration = durations[i];
                            var closingMoment = closingMomentsForToday[i];
                            if (bookingMoment.isBetween(currentMoment.clone(), currentMoment.clone().add(rangeMinutes, 'minutes')) &&
                                bookingMoment.isBefore(closingMoment.clone())) {
                                resultArray_i.push(bookingMoment);
                            }
                            var slotsTaken = Math.ceil(duration / interval);
                            for (var k = 0; k < slotsTaken; k++) {
                                var minutesToAdd = interval * (k + 1);
                                var trailingBookingMoment = bookingMoment.clone().add(minutesToAdd, 'minutes');
                                if (trailingBookingMoment.isBetween(currentMoment.clone(), currentMoment.clone().add(rangeMinutes, 'minutes')) &&
                                    trailingBookingMoment.isBefore(closingMoment.clone())) {
                                    resultArray_i.push(trailingBookingMoment);
                                }
                            }
                        }
                        arrayOfBookingsMoment.push(resultArray_i);
                    }
                    console.log('arrayOfBookingsMoment');
                    console.log(arrayOfBookingsMoment);


                    var arrayOfTimeStrings = [];

                    function generateTimeStrings(bookingMoment) {
                        var hours = bookingMoment.get('hours');
                        var minutes = bookingMoment.get('minutes');
                        var timeString = String(hours) + ':' + String(minutes);
                        return timeString;
                    }

                    for (i = 0; i < arrayOfBookingsMoment.length; i++) {
                        var bookingsMoment = arrayOfBookingsMoment[i];
                        console.log(bookingsMoment);
                        var timeStrings = _.map(bookingsMoment, generateTimeStrings);
                        if (timeStrings.length === 0) {
                            timeStrings = ['available'];
                        }
                        arrayOfTimeStrings.push(timeStrings);
                    }
                    console.log('arrayOfTimeStrings');
                    console.log(arrayOfTimeStrings);

                    var arrayOfGroupedTimeStrings = [];
                    angular.forEach(arrayOfTimeStrings, function(timeStrings) {
                        var groupedTimeStrings = _.groupBy(timeStrings, function(timeString) {
                            return timeString;
                        });
                        arrayOfGroupedTimeStrings.push(groupedTimeStrings);
                    });
                    console.log('arrayOfGroupedTimeStrings');
                    console.log(arrayOfGroupedTimeStrings);

                    var availabilities = [];
                    for (i = 0; i < arrayOfGroupedTimeStrings.length; i++) {
                        var availabilityFlag = false;
                        var place_i = places[i];
                        for (var key in arrayOfGroupedTimeStrings[i]) {
                            if (arrayOfGroupedTimeStrings[i][key].length < place_i.employee || key === 'available') {
                                availabilities.push('available');
                                availabilityFlag = true;
                                break;
                            }
                        }
                        if (availabilityFlag === false) {
                            availabilities.push('unavailable');
                        }
                    }
                    console.log('availabilities');
                    console.log(availabilities);
                    return availabilities;
                }

                function processPin(markerImg, markerClickedImg, scope) {

                    angular.forEach(DaumMapModel.places, function(place, i) {
                        //place = {location:{type:'Point', coordinates:[126.10101, 27.101010]}, ...}
                        var placeLongitude = place.location.coordinates[0];
                        var placeLatitude = place.location.coordinates[1];
                        // set marker
                        var position = new daum.maps.LatLng(placeLatitude, placeLongitude);
                        var marker = new daum.maps.Marker({
                            map: map,
                            position: position,
                            // used as to link to place info
                            title: String(i),
                            image: markerImg,
                            clickable: true
                        });
                        daum.maps.event.addListener(marker, 'click', function() {
                            var marker = this;
                            scope.$apply(function() {
                                // on click: differentiate clicked image;
                                angular.forEach(DaumMapModel.markers, function(otherMarker) {
                                    otherMarker.setImage(markerImg);
                                });
                                marker.setImage(markerClickedImg);
                                // on click: show modal which will be filled with place info
                                // modal references DaumMapModel.selectedPlace to fill in the info
                                var index = Number(marker.getTitle());
                                Message.loading.default();

                                Places.findById({
                                    id: DaumMapModel.places[index].id,
                                    populates: 'photos'
                                }).$promise
                                    .then(function success(data) {
                                        Message.loading.hide();
                                        DaumMapModel.selectedPlace = data;
                                        console.log(DaumMapModel.selectedPlace);
                                        DaumMapModel.modal.show();
                                    }, function err(error) {
                                        console.log(error);
                                        Message.loading.hide();
                                        Message.popUp.alert.default();

                                    });
                                // DaumMapModel.selectedPlace = DaumMapModel.places[index];
                            });
                        });
                        // Save converted place with click event added.
                        DaumMapModel.markers.push(marker);
                    });
                }

                // Draw Markers after query
                var drawMarkers = function(currentCenter, markerImg, markerClickedImg, scope) {
                    // Reset previous markers;
                    angular.forEach(DaumMapModel.markers, function(marker) {
                        marker.setMap(null);
                    });
                    DaumMapModel.markers = [];

                    // Request server for places;
                    Places.getPlacesWithin({
                        latitude: currentCenter.latitude,
                        longitude: currentCenter.longitude,
                        distance: currentCenter.distance || 5000,
                        limit: currentCenter.limit || 50,
                        filter: filterValue || null,
                    }).$promise
                        .then(function success(placesWrapper) {

                            if ($stateParams.from === 'quick') {

                                filterPlaces(placesWrapper.places, 60)
                                    .then(function success(places) {
                                        DaumMapModel.places = places;
                                        processPin(markerImg, markerClickedImg, scope);
                                    }, function err(error) {
                                        console.log(error);
                                    });

                            } else {
                                DaumMapModel.places = placesWrapper.places;
                                processPin(markerImg, markerClickedImg, scope);
                            }
                            Message.loading.hide();
                            filterValue = null;

                        }, function error(err) {
                            console.log(err);
                            filterValue = null;
                        });
                };

                //==========================================================================
                //              Find Current location and search nearby
                //==========================================================================
                DaumMapModel.findMeThenSearchNearBy = function() {
                    Message.loading.default();
                    // filterValue = null;
                    $cordovaGeolocation.getCurrentPosition({
                        maximumAge: 3000,
                        timeout: 5000
                    })
                        .then(function success(position) {

                            if (position.coords == null) {
                                Message.loading.hide();
                                Message.popUp.alert.default(
                                    '위치 공유가 꺼져있습니다.',
                                    '위치 공유가 켜주세요.'
                                );
                                return false;
                            }

                            DaumMapModel.currentPosition = {
                                latitude: position.coords.latitude,
                                longitude: position.coords.longitude
                            };

                            map.setCenter(new daum.maps.LatLng(
                                DaumMapModel.currentPosition.latitude,
                                DaumMapModel.currentPosition.longitude
                            ));

                            // No longer needed as when map's center is moved it will draw.
                            // drawMarkers(currentCenter);
                            Message.loading.hide();
                        }, function error(err) {
                            console.log(err);
                            Message.loading.hide();
                            Message.popUp.alert.default(
                                '위치 공유가 꺼져있습니다.',
                                '위치 공유가 켜주세요.'
                            );
                        });
                };
                //==========================================================================
                //              Find specific location with value and search nearby
                //==========================================================================
                DaumMapModel.searchLocationNearBy = function(value) {
                    Message.loading.default();
                    if (!value) {
                        Message.loading.hide();
                        Message.popUp.alert.default('검색하기 알림', '장소 값을 넣어서 다시 검색해주세요');
                        return false;
                    }
                    // filterValue = null;
                    ps.keywordSearch(value, function(status, data) {

                        // if no search result, notify and exit.
                        if (data.places[0] === undefined) {
                            Message.loading.hide();
                            Message.popUp.alert.default(
                                '요청하신 장소가 없습니다',
                                '다시검색해주세요'
                            );
                            return false;
                        }
                        console.log(status);

                        // move to center of searched result.
                        map.panTo(new daum.maps.LatLng(
                            data.places[0].latitude,
                            data.places[0].longitude
                        ));

                        // No longer needed as when map's center is moved it will draw.
                        // drawMarkers(currentCenter);

                        Message.loading.hide();
                    }, function(err) {
                        console.log(err);
                        console.log(err);
                        Message.loading.hide();
                        Message.popUp.alert.default({
                            title: '위치 공유가 꺼져있습니다.',
                            template: '위치 공유가 켜주세요.'
                        });
                    });
                };


                DaumMapModel.searchPlaceByName = function(value) {

                    Message.loading.default();

                    if (!value) {
                        Message.loading.hide();
                        Message.popUp.alert.default('검색하기 알림', '장소 값을 넣어서 다시 검색해주세요');
                        return false;
                    }
                    filterValue = value;

                    // Request server for places;
                    Places.getPlaces({
                        category: 'NAIL-PLACE',
                        filter: value,
                        limit: 50
                    }).$promise
                        .then(function success(placesWrapper) {


                            if (placesWrapper.places && placesWrapper.places.length > 0) {
                                map.panTo(new daum.maps.LatLng(
                                    placesWrapper.places[0].location.coordinates[1],
                                    placesWrapper.places[0].location.coordinates[0]
                                ));

                            } else {
                                Message.loading.hide();
                                Message.popUp.alert.default(
                                    '요청하신 장소가 없습니다',
                                    '다시검색해주세요'
                                );
                                return false;
                            }

                            Message.loading.hide();

                        }, function error(err) {
                            console.log(err);
                        });
                };


                return function(scope) {
                    // Marker style properties.
                    var markerSize = new daum.maps.Size(scope.markerWidth, scope.markerHeight);
                    var markerImg = new daum.maps.MarkerImage(scope.markerSrc, markerSize);
                    var markerClickedImg = new daum.maps.MarkerImage(scope.markerClickedSrc, markerSize);
                    map.relayout();
                    DaumMapModel.domMap = map;
                    // ------------------------
                    //  Search when moved
                    // ------------------------

                    daum.maps.event.addListener(map, 'idle', function() {

                        Message.loading.default();
                        var currentCenter = {
                            longitude: map.getCenter().getLng(),
                            latitude: map.getCenter().getLat()
                        };

                        angular.extend(currentCenter, {
                            distance: 2000,
                            limit: 20
                        });

                        console.log(currentCenter);
                        drawMarkers(currentCenter, markerImg, markerClickedImg, scope);

                    });
                };
            }
        };
    }

})();

(function() {
    'use strict';
    angular.module('app')
        .factory('DaumMapModel', DaumMapModel);

    function DaumMapModel() {
        var model = {
            // need to specify category for search
            category: 'NAIL-PLACE', // only one category hence fixed
            currentPosition: {
                latitude: 'FLOAT',
                longitude: 'FLOAT'
            },
            markers: [],
            places: [],
            selectedPlace: {
                // response.places[n] selected from DaumMapDirective
            },
            modal: {
                //Defined in DaumMapController
            },
            findMeThenSearchNearBy: function() {
                //Defined in DaumMapDirective
            },
            searchLocationNearBy: function() {
                //Defined in DaumMapDirective
            },
        };

        return model;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .controller('DetailController', DetailController);

    DetailController.$inject = [
        'DetailModel', '$stateParams', '$scope', 'Message', 'Places',
        '$ionicSlideBoxDelegate', '$state', 'Favorite', '$filter', 'moment'
    ];

    function DetailController(DetailModel, $stateParams, $scope, Message, Places,
        $ionicSlideBoxDelegate, $state, Favorite, $filter, moment
    ) {
        var filterByTag = $filter('filterByTag');

        var Detail = this;
        Detail.Model = DetailModel;

        // Detail.date will update as user picks the date.
        Detail.date = moment();
        Detail.isFavorite = Favorite.isFavorite.bind(null, 'NAIL_SAVED_PLACES');
        Detail.interiorPhotos = [];
        Detail.portFolioPhotos = [];
        Detail.toggleSavePlace = Favorite.saveToFavorite.bind(null, 'NAIL_SAVED_PLACES', Detail, DetailModel);

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
        function loadPlace() {
            Message.loading.default();

            return Places.findById({
                    id: $stateParams.id,
                    populates: 'photos,products,bookings'
                }).$promise
                .then(function success(place) {
                    DetailModel.current = place;
                    console.log('this');
                    console.log(place);
                    Detail.interiorPhotos = filterByTag(DetailModel.current.photos, 'INTERIOR');
                    // Detail.portFolioPhotos = filterByTag(DetailModel.current.photos, 'PORTFOLIO');

                    Message.loading.hide();
                    $ionicSlideBoxDelegate.update();

                }, function error(err) {
                    console.log(err);
                    Message.popUp.alert.default(
                        '네일샵정보 알림',
                        '요청하신 네일샵은 더이상 존재하지 않습니다.'
                    );
                });
        }

        function loadPortfolioPhotos() {
            return Places.getPlacePhotos({
                    id: $stateParams.id,
                    tags: 'PORTFOLIO'
                }).$promise
                .then(function success(photos) {
                    Detail.portFolioPhotos = photos;
                    console.log(photos);
                }, function err(error) {
                    console.log(error);
                });
        }

        function doBeforeEnter() {
            loadPlace();
            loadPortfolioPhotos();
        }

    }
})();

(function() {
    'use strict';
    angular.module('app')
        .factory('DetailModel', DetailModel);

    DetailModel.$inject = ['$q', '$state', '$stateParams', 'moment'];

    function DetailModel($q, $state, $stateParams, moment) {

        var model = {

            current: {
                openingHours: [{
                    start: '00:00',
                    end: '00:00'
                }, {
                    start: '07:00',
                    end: '20:00'
                }, {
                    start: '07:00',
                    end: '20:00'
                }, {
                    start: '07:00',
                    end: '20:00'
                }, {
                    start: '07:00',
                    end: '20:00'
                }, {
                    start: '09:00',
                    end: '22:00'
                }, {
                    start: '09:00',
                    end: '22:00'
                }]
            },
            selectedDate: {
                // dt from datepickeruibootstrap
                current: 'BOOL',
                customClass: 'STRING',
                date: 'DATE',
                disabled: 'BOOL',
            },
            //Coupled with ui-BootStrap.datePicker and
            //DetailModel.selectedDate
            dayClickHandler: function(dt) {
                // copies selected date then do below;
                var shopId = $stateParams.id;
                console.log(shopId);

                // dt.date = 2015-08-04
                var selectedDate = moment(dt.date);

                $state.go('main.schedule', {
                    id: shopId,
                    selectedDate: selectedDate.format('YYYY-MM-DD')
                });
            },

        };


        return model;

    }


})();

(function() {
    'use strict';

    angular.module('app')
        .controller('FavoriteController', FavoriteController);

    FavoriteController.$inject = ['FavoriteModel', '$scope', '$state', 'localStorage'];

    function FavoriteController(FavoriteModel, $scope, $state, localStorage) {
        var Favorite = this;
        Favorite.Model = FavoriteModel;
        Favorite.goToDetailHandler = goToDetailHandler;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------

        function goToDetailHandler(place) {
            $state.go('main.detail', {
                id: place.id
            });
        }

        function doBeforeEnter() {
            FavoriteModel.placeList = angular.fromJson(localStorage.getItem('NAIL_SAVED_PLACES'));
        }

    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('FavoriteModel', FavoriteModel);



    function FavoriteModel() {

        var model = {

        };

        return model;

    }

})();
(function() {
    'use strict';
    angular.module('app')
        .controller('LoginController', LoginController);

    LoginController.$inject = ['LoginModel', 'AuthService', 'Message', '$state'];

    function LoginController(LoginModel, AuthService, Message, $state) {

        var Login = this;
        Login.Model = LoginModel;

        Login.loginWithFaceBook = loginWithFacebook;
        Login.loginWithKaKaoTalk = loginWithKaKaoTalk;
        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
        function loginWithFacebook() {
            return AuthService.loginWithFacebook()
                .then(function success(data) {
                    console.log(data);
                    Message.loading.hide();
                    $state.go('main.home');
                }, function err(error) {
                    console.log(error);
                });
        }

        function loginWithKaKaoTalk() {
            return AuthService.loginWithKakao()
                .then(function(data) {
                    console.log(data);
                    Message.loading.hide();
                    $state.go('main.home');
                }, function err(error) {
                    console.log(error);
                });
        }
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('LoginModel', LoginModel);

    // LoginModel.$inject = [];

    function LoginModel() {

        var model = {

        };
        return model;
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .controller('MainController', MainController);

    MainController.$inject = ['$ionicSideMenuDelegate', 'MainModel', '$state', '$timeout',
        '$ionicNavBarDelegate', '$ionicHistory', 'localStorage', '$scope', 'appName', 'Devices'
    ];

    function MainController($ionicSideMenuDelegate, MainModel, $state, $timeout,
        $ionicNavBarDelegate, $ionicHistory, localStorage, $scope, appName, Devices) {

        var Main = this;
        Main.Model = MainModel;

        Main.toggleSideMenu = toggleSideMenu;
        Main.menuSelectHandler = menuSelectHandler;
        Main.getCurrentState = getCurrentState;
        Main.toggleAccordion = toggleAccordion;
        Main.toggleSettingHandler = togglePushHandler;
        Main.goToDaumMapHandler = goToDaumMapHandler;
        Main.displayUserName = displayUserName;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
        function toggleSideMenu() {
            $ionicSideMenuDelegate.toggleLeft();
        }

        function menuSelectHandler(item) {
            MainModel.currentItem = item;
            $state.go(item.state);
            $ionicSideMenuDelegate.toggleLeft(false);
        }

        function getCurrentState() {
            return $ionicHistory.currentStateName();

        }

        function toggleAccordion() {
            Main.settingSubMenu = !Main.settingSubMenu;
        }

        function togglePushHandler() {
            if (MainModel.setting.pushNotification === true) {
                MainModel.setting.pushNotification = false;
            } else {
                MainModel.setting.pushNotification = true;
            }
            var deviceId = Devices.getDeviceIdSync();
            console.log(deviceId);
            //req server to turn off setting.
            Devices.update({
                deviceId: deviceId
            }, {
                active: MainModel.setting.pushNotification
            }).$promise
                .then(function success(data) {
                    console.log(data);
                }, function err(error) {
                    console.log(error);
                });
        }

        function goToDaumMapHandler() {
            $state.go('main.daumMap');
        }

        function doBeforeEnter() {
            var userWrapper = angular.fromJson(localStorage.getItem(appName + '_' + 'auth_token'));
            MainModel.user = userWrapper.user;
            console.log(MainModel.user);
        }

        function displayUserName() {
            var displayName = 'User' + MainModel.user.username;

            if (MainModel.user.nickname)
                displayName = MainModel.user.nickname;

            return displayName;
        }


    } // END

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('MainModel', MainModel);

    function MainModel() {
        var model = {
            user: {
                //KaKao
                id: "55cc92edc96284828b826258",
                username: "49720641",
                nickname: "KoS",
                profile_image: "http://mud-kage.kakao.co.kr/14/dn/btqcfpt4vNR/Fmmz6xsVRH05wv1UYNniRK/o.jpg",
                thumbnail_image: "http://mud-kage.kakao.co.kr/14/dn/btqcfp1VCch/LjjO9lFj9uwxpOB59NHEnK/o.jpg",
                //Facebook
                // id: "55cclkasdjfklasjdfkl"
                // username: "49720641",
                // nickname: "KoS",
                // profile_image: "http://mud-kage.kakao.co.kr/14/dn/btqcfpt4vNR/Fmmz6xsVRH05wv1UYNniRK/o.jpg"

            },
            sideMenuLists: [{
                state: 'main.home',
                text: '홈으로 가기'
            }, {
                state: 'main.show.savedList',
                text: '마이갤러리'
            }, {
                state: 'main.balance.list',
                text: '적립금 확인'
            }, {
                state: 'main.cancel',
                text: '예약 취소'
            }, {
                state: 'main.announcements.eventList',
                text: '이벤트 / 공지사항'
            }],
            currentItem: {
                state: 'main.home',
                text: '홈으로 가기'
            },
            setting: {
                pushNotification: true
            }
        };

        return model;
    }

})();

(function() {
    'use strict';
    angular.module('app')
        .controller('MainHomeController', MainHomeController);
    MainHomeController.$inject = ['MainHomeModel', '$state'];

    function MainHomeController(MainHomeModel, $state) {

        var Home = this;

        Home.search = '';


        Home.goToHandler = goToHandler;
        Home.searchHandler = searchHandler;

        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
        function goToHandler(state, params) {
            $state.go(state, params);
        }

        function searchHandler(search) {
            console.log(search);
            $state.go('main.daumMap', {
                from: 'homeInput'
            });
        }
    }
})();

(function() {
    'use strict';

    angular.module('app')
        .factory('MainHomeModel', MainHomeModel);

    function MainHomeModel() {

        var model = {

        };
        return model;
    }
})();
(function() {
    'use strict';
    angular.module('app')
        .controller('ScheduleController', ScheduleController);

    ScheduleController.$inject = ['DetailModel', 'ScheduleModel', 'Places', 'Bookings', 'Message',
        '$scope', '$ionicModal', '$q', '$stateParams', '$http', 'governorUrl', 'moment', '_'
    ];

    function ScheduleController(DetailModel, ScheduleModel, Places, Bookings, Message,
        $scope, $ionicModal, $q, $stateParams, $http, governorUrl, moment, _) {

        var interval = 30;

        var Schedule = this;
        Schedule.Model = ScheduleModel;

        ScheduleModel.current = DetailModel.current;

        Schedule.selectSlotHandler = selectSlotHandler;
        Schedule.isSelectedSlot = isSelectedSlot;
        Schedule.isAvailableSlot = isAvailableSlot;
        //Modal scope logic
        Schedule.selectProductHandler = selectProductHandler;
        Schedule.isSelectedProduct = isSelectedProduct;
        Schedule.closeModalHandler = closeModalHandler;
        Schedule.bookingHandler = bookingHandler;

        $scope.$on('$ionicView.beforeEnter', doBeforeEnter);
        $scope.$on('$ionicView.afterEnter', doAfterEnter);


        //------------------------
        //  IMPLEMENTATIONS
        //------------------------
        function selectSlotHandler(reserveSlot, index) {
            ScheduleModel.selectedSlot = reserveSlot;
            ScheduleModel.selectedIndex = index;
            if (reserveSlot.bookingCount >= DetailModel.current.employee) {
                Message.popUp.alert.default(
                    '예약불가 알림',
                    '예약이 꽉 차있는 시간입니다.'
                );
                return false;
            }
            Schedule.modal.show();
            ScheduleModel.form.datetime = reserveSlot.toDate();
        }

        function isSelectedSlot(reserveSlot) {
            var selectedHourString = ScheduleModel.selectedSlot.get && ScheduleModel.selectedSlot.get('hour');
            var selectedMinuteString = ScheduleModel.selectedSlot.get && ScheduleModel.selectedSlot.get('minute');
            var selectedTimeString = selectedHourString + ':' + selectedMinuteString;
            var reserveSlotHourString = reserveSlot.get && reserveSlot.get('hour');
            var reserveSlotMinuteString = reserveSlot.get && reserveSlot.get('minute');
            var reserveSlotTimeString = reserveSlotHourString + ':' + reserveSlotMinuteString;
            return selectedTimeString === reserveSlotTimeString;
        }

        function isAvailableSlot(reserveSlot) {
            if (reserveSlot.bookingCount != null && DetailModel.current.employee != null) {
                return Number(DetailModel.current.employee) > reserveSlot.bookingCount;
            } else {
                return true;
            }
        }

        //------------------------
        // LOGIC INSIDE BOOKING MODAL
        //------------------------
        function selectProductHandler(product) {
            ScheduleModel.form.products = [{
                product: product
            }];
        }

        function isSelectedProduct(product) {
            return ((ScheduleModel.form.products && ScheduleModel.form.products[0] && ScheduleModel.form.products[0].product.id) === product.id);
        }

        function closeModalHandler() {
            Bookings.getBookingsDateBetween({
                placeId: $stateParams.id,
                from: moment($stateParams.selectedDate).clone().toDate().getTime(),
                to: moment($stateParams.selectedDate).clone().add(1, 'days').toDate().getTime()
            }).$promise
                .then(function success(data) {
                    // update viewSlots
                    ScheduleModel.viewSlots = generateReserveMomentSlots($stateParams.selectedDate, DetailModel.current.openingHours, 30, true);
                    updateSlotsWithBookings(data);
                    angular.copy({}, ScheduleModel.form);
                    Schedule.modal.hide();
                });
        }

        function bookingHandler() {
            ScheduleModel.form.place = $stateParams.id;
            ScheduleModel.form.category = 'NAIL-BOOKING';
            // Validation
            if (ScheduleModel.form.products[0] == null) {
                return reserveErrorHelper('서비스란');
            } else if (ScheduleModel.form.userKoreanName == null) {
                return reserveErrorHelper('이름란');
            } else if (ScheduleModel.form.userPhoneNumber == null) {
                return reserveErrorHelper('연락처란');
            }

            Message.loading.default();

            Bookings.getBookingsDateBetween({
                placeId: $stateParams.id,
                from: moment($stateParams.selectedDate).clone().toDate().getTime(),
                to: moment($stateParams.selectedDate).clone().add(1, 'days').toDate().getTime()
            }).$promise
                .then(function success(data) {
                    ScheduleModel.viewSlots = generateReserveMomentSlots($stateParams.selectedDate, DetailModel.current.openingHours, 30, true);
                    updateSlotsWithBookings(data);
                    var selectedSlotIsBookable = isSelectedSlotBookable();
                    if (selectedSlotIsBookable) {
                        makeBooking();
                    }
                }, function err(error) {
                    console.log(error);
                });
        }

        function doBeforeEnter() {
            var openingHours = DetailModel.current.openingHours;
            ScheduleModel.viewSlots = generateReserveMomentSlots($stateParams.selectedDate, openingHours, 30, true);
            Bookings.getBookingsDateBetween({
                placeId: $stateParams.id,
                from: moment($stateParams.selectedDate).clone().toDate().getTime(),
                to: moment($stateParams.selectedDate).clone().add(1, 'days').toDate().getTime()
            }).$promise
                .then(function success(bookingsWrapper) {
                    console.log(bookingsWrapper);
                    updateSlotsWithBookings(bookingsWrapper);
                }, function err(error) {
                    console.log(error);
                });
        }

        function generateReserveMomentSlots(selectedDateString, openingHoursArray, interval, ableToBookAtEndTimeBool) {
            // get day of reservedDate, in UTC+9
            var reserveMoment = moment(selectedDateString).set({
                hour: 0,
                minute: 0,
                second: 0
            });
            // get day of selected date
            var dayOfWeek = reserveMoment.day();
            // Get opening hours of that day
            //{start: '07:00', end: '20:00'}
            var hoursObj = openingHoursArray[dayOfWeek];

            // Convert strings to date object.
            var startTimeArray = hoursObj.start.split(':');
            var endTimeArray = hoursObj.end.split(':');

            var startHour = startTimeArray[0];
            var startMinute = startTimeArray[1];
            var endHour = endTimeArray[0];
            var endMinute = endTimeArray[1];

            var startInMinutes = Number(startHour) * 60 + Number(startMinute);
            var endInMinutes = ableToBookAtEndTimeBool ? Number(endHour) * 60 + Number(endMinute) + interval :
                Number(endHour) * 60 + Number(endMinute);

            var arrayOfSlotsInMinutes = _.range(startInMinutes, endInMinutes, interval);

            var arrayOfSlotsInMoment = [];
            angular.forEach(arrayOfSlotsInMinutes, function(minutes) {
                var reserveMomentCopy = reserveMoment.clone();
                var slot = reserveMomentCopy.set({
                    minute: minutes,
                    second: 0
                });
                arrayOfSlotsInMoment.push(slot);
            });
            // console.log(arrayOfSlotsInMoment);
            return arrayOfSlotsInMoment;
        }

        function updateSlotsWithBookings(bookingsWrapper) {
            var viewSlots = ScheduleModel.viewSlots;
            var bookings = ScheduleModel.bookings = bookingsWrapper.bookings;
            // var employee = DetailModel.current.employee;
            // var interval = 30;

            angular.forEach(bookings, function(booking) {
                // get beginning time(inclusive)
                var begBookingMoment = moment.utc(booking.datetime).local()
                    .add(1, 'seconds');
                var duration = booking.products[0].product && booking.products[0].product.duration;
                // if begTime is between reserveSlot
                // for each viewslots
                var viewSlotEnd = '';
                for (var i = 0; i < viewSlots.length; i++) {
                    if (i < viewSlots.length - 1) {
                        viewSlotEnd = viewSlots[i + 1];
                        // if index is the last one.
                    } else if (i === viewSlots.length - 1) {
                        viewSlotEnd = viewSlots[i].clone().add(interval, 'minutes');
                    }

                    // if beginning of booking time is between reserveSlot
                    if (begBookingMoment.isBetween(viewSlots[i], viewSlotEnd)) {
                        // get number of slots to increament booking count;
                        var numberOfSlotsTaken = Math.ceil(Number(duration) / Number(interval));
                        // increment affected slots bookingCount;
                        for (var j = 0; j < numberOfSlotsTaken; j++) {
                            if (!viewSlots[i + j].bookingCount) {
                                viewSlots[i + j].bookingCount = 1;
                            } else {
                                viewSlots[i + j].bookingCount += 1;
                            }
                        }
                        break;
                    }
                }
            });
        }

        function doAfterEnter() {
            // Set Modal
            $ionicModal.fromTemplateUrl('state/schedule/reserveModal.html', {
                scope: $scope,
                animation: 'slide-in-up'
            })
                .then(function(modal) {
                    Schedule.modal = modal;
                });
        }

        function isSelectedSlotBookable() {
            var index = ScheduleModel.selectedIndex;
            var duration = ScheduleModel.form.products[0].product.duration;
            var numberOfSlots = Math.ceil(duration / interval);
            for (var i = index; i < index + numberOfSlots; i++) {
                // service crashes with other times
                var bookingCounts = ScheduleModel.viewSlots[i].bookingCount ? ScheduleModel.viewSlots[i].bookingCount : 0;
                if (bookingCounts >= Number(DetailModel.current.employee)) {
                    Message.loading.hide();
                    Message.popUp.alert.default(
                        '예약 불가 안내',
                        '고르신 서비스의 시간이 다음 예약시간과 겹치게 되어 예약이 불가합니다.'
                    );
                    return false;
                }
                // service goes out of business hours
                if (index + numberOfSlots > ScheduleModel.viewSlots.length) {
                    Message.loading.hide();
                    Message.popUp.alert.default(
                        '예약 불가 안내',
                        '고르신 서비스의 마무리시간이 영업 종료시간을 넘기어 예약이 불가합니다.'
                    );
                    return false;
                }
            }
            return true;
        }

        function makeBooking() {

            return Bookings.requestBooking({}, Schedule.Model.form).$promise
                .then(function success(data) {
                    Message.loading.hide();
                    Message.popUp.alert.default(
                        '예약 완료 알림',
                        '예약이 완료 되었습니다.'
                    ).then(function(response) {
                        console.log(response);
                        Schedule.closeModalHandler();
                    });
                    console.log(data);
                }, function err(error) {
                    Message.loading.hide();
                    console.log(error);
                });
            // $http({
            //     url: governorUrl + '/booking/request',
            //     method: 'POST',
            //     headers: {
            //         'Content-Type': 'application/json'
            //     },
            //     data: Schedule.Model.form
            // })
            //     .success(function(data) {
            //         Message.loading.hide();
            //         Message.popUp.alert.default(
            //             '예약 완료 알림',
            //             '예약이 완료 되었습니다.'
            //         ).then(function(response) {
            //             Schedule.closeModalHandler();
            //             console.log(response);
            //         });
            //         console.log(data);

            //     })
            //     .error(function(error) {
            //         console.log(error);

            //         Message.loading.hide();
            //     });
        }


        //==========================================================================
        //              Check reserve inputs
        //==========================================================================
        function reserveErrorHelper(korean) {
            Message.popUp.alert.default(
                korean + '이 비었습니다.',
                korean + '을 입력/골라 주세요.'
            );
        }





    }


})();

(function() {
    'use strict';
    angular.module('app')
        .factory('ScheduleModel', ScheduleModel);

    function ScheduleModel() {

        var model = {
            current: {
                openingHours: [{
                    start: '00:00',
                    end: '00:00'
                }, {
                    start: '07:00',
                    end: '20:00'
                }, {
                    start: '07:00',
                    end: '20:00'
                }, {
                    start: '07:00',
                    end: '20:00'
                }, {
                    start: '07:00',
                    end: '20:00'
                }, {
                    start: '09:00',
                    end: '22:00'
                }, {
                    start: '09:00',
                    end: '22:00'
                }]
            },
            selectedSlot: {
                //moment object
            },
            viewSlots: ['moment', 'moment', 'moment'],
            bookings: [{
                datetime: 'datetime',
                products: [{
                    duration: "30"
                }]
            }],

            form: {
                products: [''],
                userKoreanName: null,
                userPhoneNumber: null,
                datetime: new Date(),
                place: 'placeId',
                category: 'NAIL-BOOKING'
            }

        };

        return model;

    }


})();

(function() {
    'use strict';

    angular.module('app')
        .controller('ShowController', ShowController);

    ShowController.$inject = ['ShowModel', 'Posts', '$state', '$ionicModal', '$scope', 'ShowListModel',
        '$cordovaCamera', 'Message', '$timeout', '$window', '$cordovaFile'
    ];

    function ShowController(ShowModel, Posts, $state, $ionicModal, $scope, ShowListModel,
        $cordovaCamera, Message, $timeout, $window, $cordovaFile
    ) {

        var Show = this;

        $ionicModal.fromTemplateUrl('state/show/showModal.html', {
            scope: $scope,
            animation: 'slide-in-up'
        }).then(function(modal) {
            Show.modal = modal;
        });

        Show.modalHideHandler = function() {
            Show.writeImageSrc = null;
            Show.writeTitle = null;
            Show.writeContent = null;
            Show.modal.hide();
        };

        Show.modalShowHandler = function() {
            Show.modal.show();
        };

        Show.goToSavedPostListHandler = function() {
            $state.go('main.show.savedList');
        };

        //------------------------
        //  Write post logic
        //------------------------
        Show.showWriteImage = function() {
            return Show.writeImageSrc != null;
        };

        Show.getPictureHandler = function(sourceType) {

            // photoLibrary: 0,
            // camera: 1
            // try {
            //     $cordovaCamera.cleanup();
            // } catch (err) {
            //     console.log(err);
            // }

            if (sourceType === undefined) {
                sourceType = 1;
            }

            console.log(sourceType);
            var options = {
                allowEdit: true,
                quality: 50,
                // destinationType: Camera.DestinationType.DATA_URL,
                destinationType: Camera.DestinationType.FILE_URI,
                encodingType: Camera.EncodingType.JPEG, // PNG do not work
                correctOrientation: true,
                targetWidth: 500,
                mediaType: Camera.MediaType.PICTURE,
                // saveToPhotoAlbum: true,
                cameraDirection: Camera.Direction.BACK, // FRONT do not work
                sourceType: sourceType
            };

            $cordovaCamera.getPicture(options)
                .then(function success(imageUrl) {
                    Show.writeImageFile = imageUrl;

                    var name = imageUrl.substr(imageUrl.lastIndexOf('/') + 1);
                    var namePath = imageUrl.substr(0, imageUrl.lastIndexOf('/') + 1);

                    $cordovaFile.readAsDataURL(namePath, name)
                        .then(function(dataUri) {
                            console.log(dataUri);
                            Show.writeImageSrc = dataUri;
                        }, function(error) {
                            console.log(error);
                        });

                }, function error(err) {
                    console.log(err);
                });

        };


        Show.postHandler = function() {
            Message.loading.default();

            var postWithFile = {
                category: 'SHOW-POST',
                title: Show.writeTitle,
                content: Show.writeContent,
                file: Show.writeImageFile
            };

            Posts.createPostWithImage({}, postWithFile).$promise
                .then(function success() {
                    Show.writeTitle = '';
                    Show.writeContent = '';
                    Show.writeImageSrc = null;
                    Show.writeImageFile = '';
                    Message.loading.hide();
                    Message.message.success('포스트가 만들어졌습니다.');
                    Show.modal.hide();
                    $timeout(function() {
                        $state.go('main.show.list', {}, {
                            reload: true
                        });
                    }, 1500);
                }, function err(error) {
                    console.log(error);
                    Message.loading.hide();
                    Message.message.error('다시 시도해주세요.');
                }, function progress(prog) {
                    console.dir(prog);
                });
            // var options = {
            //     params: postWithFile,
            //     chunkedMode: false,
            //     headers: {
            //         Connection: "close",
            //         Authorization: 'Bearer ' + AuthService.getToken()
            //     }
            // };
            // var ft = new FileTransfer();
            // ft.upload('', encodeURI('http://192.168.0.65:1337' + '/post'), success, fail, options, true);

            // function success() {

            // }

            // function fail() {

            // }
        };



        // END

    }

})();

(function() {
    'use strict';

    angular.module('app')
        .factory('ShowModel', ShowModel);

    // ShowModel.$inject = [];

    function ShowModel() {

        var model = {

        };
        return model;
    }
})();
